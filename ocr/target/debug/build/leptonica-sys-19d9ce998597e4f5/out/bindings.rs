/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LIBLEPT_MAJOR_VERSION: u32 = 1;
pub const LIBLEPT_MINOR_VERSION: u32 = 82;
pub const LIBLEPT_PATCH_VERSION: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120100;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const _X86_INSTRUCTION_STATE_MAX_INSN_BYTES: u32 = 2380;
pub const _X86_INSTRUCTION_STATE_CACHELINE_SIZE: u32 = 64;
pub const __LASTBRANCH_MAX: u32 = 32;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_CURRENT: u32 = 5;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __GNUC_VA_LIST: u32 = 1;
pub const HAVE_LIBJPEG: u32 = 1;
pub const HAVE_LIBTIFF: u32 = 1;
pub const HAVE_LIBPNG: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LIBGIF: u32 = 0;
pub const HAVE_LIBUNGIF: u32 = 0;
pub const HAVE_LIBWEBP: u32 = 0;
pub const HAVE_LIBWEBP_ANIM: u32 = 0;
pub const HAVE_LIBJP2K: u32 = 0;
pub const USE_BMPIO: u32 = 1;
pub const USE_PNMIO: u32 = 1;
pub const USE_JP2KHEADER: u32 = 1;
pub const USE_PDFIO: u32 = 1;
pub const USE_PSIO: u32 = 1;
pub const HAVE_FMEMOPEN: u32 = 1;
pub const HAVE_FSTATAT: u32 = 0;
pub const UNDEF: i32 = -1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const NUMA_VERSION_NUMBER: u32 = 1;
pub const DNA_VERSION_NUMBER: u32 = 1;
pub const SARRAY_VERSION_NUMBER: u32 = 1;
pub const USE_INLINE_ACCESSORS: u32 = 1;
pub const DEWARP_VERSION_NUMBER: u32 = 4;
pub const GPLOT_VERSION_NUMBER: u32 = 1;
pub const NUM_GPLOT_STYLES: u32 = 5;
pub const NUM_GPLOT_OUTPUTS: u32 = 6;
pub const JB_TEMPLATE_EXT: &'static [u8; 15usize] = b".templates.png\0";
pub const JB_DATA_EXT: &'static [u8; 6usize] = b".data\0";
pub const SEL_VERSION_NUMBER: u32 = 1;
pub const KERNEL_VERSION_NUMBER: u32 = 2;
pub const PIX_SRC: u32 = 12;
pub const PIX_DST: u32 = 10;
pub const PIX_CLR: u32 = 0;
pub const PIX_SET: u32 = 15;
pub const PIX_PAINT: u32 = 14;
pub const PIX_MASK: u32 = 8;
pub const PIX_XOR: u32 = 6;
pub const PIXAA_VERSION_NUMBER: u32 = 2;
pub const PIXA_VERSION_NUMBER: u32 = 2;
pub const BOXA_VERSION_NUMBER: u32 = 2;
pub const BOXAA_VERSION_NUMBER: u32 = 3;
pub const PTA_VERSION_NUMBER: u32 = 1;
pub const FPIX_VERSION_NUMBER: u32 = 2;
pub const DPIX_VERSION_NUMBER: u32 = 2;
pub const PIXACOMP_VERSION_NUMBER: u32 = 2;
pub const RECOG_VERSION_NUMBER: u32 = 2;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
pub type size_t = __darwin_size_t;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub type ssize_t = __darwin_ssize_t;
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut size_t,
        __stream: *mut FILE,
    ) -> ssize_t;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: size_t,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut size_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: size_t,
        arg4: *const ::std::os::raw::c_char,
        arg5: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: size_t,
        arg3: ::std::os::raw::c_int,
        arg4: size_t,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __x86_instruction_state {
    pub __insn_stream_valid_bytes: ::std::os::raw::c_int,
    pub __insn_offset: ::std::os::raw::c_int,
    pub __out_of_synch: ::std::os::raw::c_int,
    pub __insn_bytes: [__uint8_t; 2380usize],
    pub __insn_cacheline: [__uint8_t; 64usize],
}
#[test]
fn bindgen_test_layout___x86_instruction_state() {
    assert_eq!(
        ::std::mem::size_of::<__x86_instruction_state>(),
        2456usize,
        concat!("Size of: ", stringify!(__x86_instruction_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__x86_instruction_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__x86_instruction_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_stream_valid_bytes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_stream_valid_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_offset as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__out_of_synch as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__out_of_synch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_bytes as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_instruction_state>())).__insn_cacheline as *const _
                as usize
        },
        2392usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_instruction_state),
            "::",
            stringify!(__insn_cacheline)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __last_branch_record {
    pub __from_ip: __uint64_t,
    pub __to_ip: __uint64_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout___last_branch_record() {
    assert_eq!(
        ::std::mem::size_of::<__last_branch_record>(),
        24usize,
        concat!("Size of: ", stringify!(__last_branch_record))
    );
    assert_eq!(
        ::std::mem::align_of::<__last_branch_record>(),
        8usize,
        concat!("Alignment of ", stringify!(__last_branch_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_record>())).__from_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_record),
            "::",
            stringify!(__from_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_record>())).__to_ip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_record),
            "::",
            stringify!(__to_ip)
        )
    );
}
impl __last_branch_record {
    #[inline]
    pub fn __mispredict(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___mispredict(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tsx_abort(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___tsx_abort(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __in_tsx(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___in_tsx(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __cycle_count(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set___cycle_count(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 13u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __mispredict: __uint32_t,
        __tsx_abort: __uint32_t,
        __in_tsx: __uint32_t,
        __cycle_count: __uint32_t,
        __reserved: __uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __mispredict: u32 = unsafe { ::std::mem::transmute(__mispredict) };
            __mispredict as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __tsx_abort: u32 = unsafe { ::std::mem::transmute(__tsx_abort) };
            __tsx_abort as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __in_tsx: u32 = unsafe { ::std::mem::transmute(__in_tsx) };
            __in_tsx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 16u8, {
            let __cycle_count: u32 = unsafe { ::std::mem::transmute(__cycle_count) };
            __cycle_count as u64
        });
        __bindgen_bitfield_unit.set(19usize, 13u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __last_branch_state {
    pub __lbr_count: ::std::os::raw::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __lbrs: [__last_branch_record; 32usize],
}
#[test]
fn bindgen_test_layout___last_branch_state() {
    assert_eq!(
        ::std::mem::size_of::<__last_branch_state>(),
        776usize,
        concat!("Size of: ", stringify!(__last_branch_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__last_branch_state>(),
        8usize,
        concat!("Alignment of ", stringify!(__last_branch_state))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_state>())).__lbr_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_state),
            "::",
            stringify!(__lbr_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__last_branch_state>())).__lbrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__last_branch_state),
            "::",
            stringify!(__lbrs)
        )
    );
}
impl __last_branch_state {
    #[inline]
    pub fn __lbr_supported_tsx(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___lbr_supported_tsx(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __lbr_supported_cycle_count(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set___lbr_supported_cycle_count(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __reserved(&self) -> __uint32_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set___reserved(&mut self, val: __uint32_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __lbr_supported_tsx: __uint32_t,
        __lbr_supported_cycle_count: __uint32_t,
        __reserved: __uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __lbr_supported_tsx: u32 = unsafe { ::std::mem::transmute(__lbr_supported_tsx) };
            __lbr_supported_tsx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __lbr_supported_cycle_count: u32 =
                unsafe { ::std::mem::transmute(__lbr_supported_cycle_count) };
            __lbr_supported_cycle_count as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let __reserved: u32 = unsafe { ::std::mem::transmute(__reserved) };
            __reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __x86_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___x86_pagein_state() {
    assert_eq!(
        ::std::mem::size_of::<__x86_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__x86_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__x86_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__x86_pagein_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__x86_pagein_state>())).__pagein_error as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__x86_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_full_state64 {
    pub __ss64: __darwin_x86_thread_state64,
    pub __ds: __uint64_t,
    pub __es: __uint64_t,
    pub __ss: __uint64_t,
    pub __gsbase: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_full_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_full_state64>(),
        200usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_full_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_full_state64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_x86_thread_full_state64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ss64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ds as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__es as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__ss as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_full_state64>())).__gsbase as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_full_state64),
            "::",
            stringify!(__gsbase)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64_full>(),
        744usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64_full))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64_full>())).__fs as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64_full),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64_full>(),
        1064usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64_full>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64_full))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx64_full>())).__fs as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64_full),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64_full {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_full_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64_full() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64_full>(),
        2664usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64_full))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64_full>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__darwin_mcontext_avx512_64_full)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64_full>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64_full>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64_full>())).__fs as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64_full),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interval_max_phys_footprint as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_runnable_time as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v5>())).ri_interval_max_phys_footprint as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_runnable_time as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v5>())).ri_flags as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
pub type rusage_info_current = rusage_info_v5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const wchar_t,
        arg3: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: size_t);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_daemon$1050"]
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: size_t,
        __width: size_t,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type l_intptr_t = isize;
pub type l_uintptr_t = usize;
pub type l_ok = ::std::os::raw::c_int;
pub type l_int8 = ::std::os::raw::c_schar;
pub type l_uint8 = ::std::os::raw::c_uchar;
pub type l_int16 = ::std::os::raw::c_short;
pub type l_uint16 = ::std::os::raw::c_ushort;
pub type l_int32 = ::std::os::raw::c_int;
pub type l_uint32 = ::std::os::raw::c_uint;
pub type l_float32 = f32;
pub type l_float64 = f64;
pub type l_int64 = ::std::os::raw::c_longlong;
pub type l_uint64 = ::std::os::raw::c_ulonglong;
extern "C" {
    pub static mut LeptDebugOK: l_int32;
}
pub const L_NOT_FOUND: ::std::os::raw::c_uint = 0;
pub const L_FOUND: ::std::os::raw::c_uint = 1;
#[doc = " Search State"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const UNIX_PATH_SEPCHAR: ::std::os::raw::c_uint = 0;
pub const WIN_PATH_SEPCHAR: ::std::os::raw::c_uint = 1;
#[doc = " Path Separators"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type L_TIMER = *mut ::std::os::raw::c_void;
#[doc = " Timing struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WallTimer {
    pub start_sec: l_int32,
    pub start_usec: l_int32,
    pub stop_sec: l_int32,
    pub stop_usec: l_int32,
}
#[test]
fn bindgen_test_layout_L_WallTimer() {
    assert_eq!(
        ::std::mem::size_of::<L_WallTimer>(),
        16usize,
        concat!("Size of: ", stringify!(L_WallTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WallTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(L_WallTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).start_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).start_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).stop_sec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).stop_usec as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_usec)
        )
    );
}
pub type L_WALLTIMER = L_WallTimer;
pub const L_SEVERITY_EXTERNAL: ::std::os::raw::c_uint = 0;
pub const L_SEVERITY_ALL: ::std::os::raw::c_uint = 1;
pub const L_SEVERITY_DEBUG: ::std::os::raw::c_uint = 2;
pub const L_SEVERITY_INFO: ::std::os::raw::c_uint = 3;
pub const L_SEVERITY_WARNING: ::std::os::raw::c_uint = 4;
pub const L_SEVERITY_ERROR: ::std::os::raw::c_uint = 5;
pub const L_SEVERITY_NONE: ::std::os::raw::c_uint = 6;
#[doc = " Control printing of error, warning and info messages */"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut LeptMsgSeverity: l_int32;
}
#[doc = " Number array: an array of floats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numa {
    #[doc = "< size of allocated number array"]
    pub nalloc: l_int32,
    #[doc = "< number of numbers saved"]
    pub n: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_int32,
    #[doc = "< x value assigned to array[0]"]
    pub startx: l_float32,
    #[doc = "< change in x value as i --> i + 1"]
    pub delx: l_float32,
    #[doc = "< number array"]
    pub array: *mut l_float32,
}
#[test]
fn bindgen_test_layout_Numa() {
    assert_eq!(
        ::std::mem::size_of::<Numa>(),
        32usize,
        concat!("Size of: ", stringify!(Numa))
    );
    assert_eq!(
        ::std::mem::align_of::<Numa>(),
        8usize,
        concat!("Alignment of ", stringify!(Numa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Numa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).startx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(startx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).delx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(delx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).array as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(array)
        )
    );
}
pub type NUMA = Numa;
#[doc = " Array of number arrays"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numaa {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of Numa saved"]
    pub n: l_int32,
    #[doc = "< array of Numa"]
    pub numa: *mut *mut Numa,
}
#[test]
fn bindgen_test_layout_Numaa() {
    assert_eq!(
        ::std::mem::size_of::<Numaa>(),
        16usize,
        concat!("Size of: ", stringify!(Numaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Numaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Numaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Numaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Numaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).numa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Numaa),
            "::",
            stringify!(numa)
        )
    );
}
pub type NUMAA = Numaa;
#[doc = " Double number array: an array of doubles"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dna {
    #[doc = "< size of allocated number array"]
    pub nalloc: l_int32,
    #[doc = "< number of numbers saved"]
    pub n: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_int32,
    #[doc = "< x value assigned to array[0]"]
    pub startx: l_float64,
    #[doc = "< change in x value as i --> i + 1"]
    pub delx: l_float64,
    #[doc = "< number array"]
    pub array: *mut l_float64,
}
#[test]
fn bindgen_test_layout_L_Dna() {
    assert_eq!(
        ::std::mem::size_of::<L_Dna>(),
        40usize,
        concat!("Size of: ", stringify!(L_Dna))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dna>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dna))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Dna), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).startx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(startx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).delx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(delx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).array as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(array)
        )
    );
}
pub type L_DNA = L_Dna;
#[doc = " Array of double number arrays"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dnaa {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of L_Dna saved"]
    pub n: l_int32,
    #[doc = "< array of L_Dna"]
    pub dna: *mut *mut L_Dna,
}
#[test]
fn bindgen_test_layout_L_Dnaa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dnaa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Dnaa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dnaa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dnaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dnaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Dnaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).dna as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dnaa),
            "::",
            stringify!(dna)
        )
    );
}
pub type L_DNAA = L_Dnaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_DnaHash {
    pub nbuckets: l_int32,
    #[doc = "< initial size of each dna that is made"]
    pub initsize: l_int32,
    #[doc = "< array of L_Dna"]
    pub dna: *mut *mut L_Dna,
}
#[test]
fn bindgen_test_layout_L_DnaHash() {
    assert_eq!(
        ::std::mem::size_of::<L_DnaHash>(),
        16usize,
        concat!("Size of: ", stringify!(L_DnaHash))
    );
    assert_eq!(
        ::std::mem::align_of::<L_DnaHash>(),
        8usize,
        concat!("Alignment of ", stringify!(L_DnaHash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).nbuckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(nbuckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).initsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(initsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).dna as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(dna)
        )
    );
}
pub type L_DNAHASH = L_DnaHash;
#[doc = " String array: an array of C strings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sarray {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of strings allocated"]
    pub n: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_int32,
    #[doc = "< string array"]
    pub array: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sarray() {
    assert_eq!(
        ::std::mem::size_of::<Sarray>(),
        24usize,
        concat!("Size of: ", stringify!(Sarray))
    );
    assert_eq!(
        ::std::mem::align_of::<Sarray>(),
        8usize,
        concat!("Alignment of ", stringify!(Sarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sarray), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(array)
        )
    );
}
pub type SARRAY = Sarray;
#[doc = " Byte array (analogous to C++ \"string\")"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bytea {
    #[doc = "< number of bytes allocated in data array"]
    pub nalloc: size_t,
    #[doc = "< number of bytes presently used"]
    pub size: size_t,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_int32,
    #[doc = "< data array"]
    pub data: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_Bytea() {
    assert_eq!(
        ::std::mem::size_of::<L_Bytea>(),
        32usize,
        concat!("Size of: ", stringify!(L_Bytea))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bytea>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bytea))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(data)
        )
    );
}
pub type L_BYTEA = L_Bytea;
#[doc = "< linear"]
pub const L_LINEAR_INTERP: ::std::os::raw::c_uint = 1;
#[doc = "< quadratic"]
pub const L_QUADRATIC_INTERP: ::std::os::raw::c_uint = 2;
#[doc = " Numa Interpolation"]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "< extended with same value"]
pub const L_CONTINUED_BORDER: ::std::os::raw::c_uint = 1;
#[doc = "< extended with constant normal derivative"]
pub const L_SLOPE_BORDER: ::std::os::raw::c_uint = 2;
#[doc = "< mirrored"]
pub const L_MIRRORED_BORDER: ::std::os::raw::c_uint = 3;
#[doc = " Numa Border Adding"]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[doc = "< convert to integer"]
pub const L_INTEGER_VALUE: ::std::os::raw::c_uint = 1;
#[doc = "< convert to float"]
pub const L_FLOAT_VALUE: ::std::os::raw::c_uint = 2;
#[doc = " Numa Data Conversion"]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[doc = " Expandable byte buffer for memory read/write operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_ByteBuffer {
    #[doc = "< size of allocated byte array"]
    pub nalloc: l_int32,
    #[doc = "< number of bytes read into to the array"]
    pub n: l_int32,
    #[doc = "< number of bytes written from the array"]
    pub nwritten: l_int32,
    #[doc = "< byte array"]
    pub array: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_ByteBuffer() {
    assert_eq!(
        ::std::mem::size_of::<L_ByteBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_ByteBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).nwritten as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nwritten)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(array)
        )
    );
}
pub type L_BBUFFER = L_ByteBuffer;
#[doc = " General hash map"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashmap {
    #[doc = "< number of stored items"]
    pub nitems: l_int32,
    #[doc = "< number of items to be stored        */"]
    pub ntogo: l_int32,
    #[doc = "< max average occupancy allowed"]
    pub maxocc: l_int32,
    #[doc = "< array of hash item ptrs"]
    pub hashtab: *mut *mut L_Hashitem,
    #[doc = "< size of array of hash item ptrs"]
    pub tabsize: l_int32,
}
#[test]
fn bindgen_test_layout_L_Hashmap() {
    assert_eq!(
        ::std::mem::size_of::<L_Hashmap>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashmap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashmap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).nitems as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(nitems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).ntogo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(ntogo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).maxocc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(maxocc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).hashtab as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(hashtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).tabsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(tabsize)
        )
    );
}
pub type L_HASHMAP = L_Hashmap;
#[doc = " Hash item, containing storage for the key, value and count.  The key"]
#[doc = "is a l_uint64, which is hashed by the mod function to find the index"]
#[doc = "into the hashtab."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashitem {
    #[doc = "< key is hashed into index into hashtab"]
    pub key: l_uint64,
    #[doc = "< number stored associated with the key"]
    pub val: l_uint64,
    #[doc = "< number of elements seen with this key"]
    pub count: l_int32,
    #[doc = "< ptr to the next in the list"]
    pub next: *mut L_Hashitem,
}
#[test]
fn bindgen_test_layout_L_Hashitem() {
    assert_eq!(
        ::std::mem::size_of::<L_Hashitem>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashitem))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashitem>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashitem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(next)
        )
    );
}
pub type L_HASHITEM = L_Hashitem;
#[doc = "< invalid operation"]
pub const L_UNDEFINED: ::std::os::raw::c_uint = 0;
#[doc = "< check if this key/val has been stored"]
pub const L_HMAP_CHECK: ::std::os::raw::c_uint = 1;
#[doc = "< create and store a hashitem if not found"]
pub const L_HMAP_CREATE: ::std::os::raw::c_uint = 2;
#[doc = " Hashmap Lookup"]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[doc = " Heap of arbitrary void* data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Heap {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of elements stored in the heap"]
    pub n: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
    #[doc = "< L_SORT_INCREASING or L_SORT_DECREASING"]
    pub direction: l_int32,
}
#[test]
fn bindgen_test_layout_L_Heap() {
    assert_eq!(
        ::std::mem::size_of::<L_Heap>(),
        24usize,
        concat!("Size of: ", stringify!(L_Heap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Heap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Heap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Heap), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).direction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(direction)
        )
    );
}
pub type L_HEAP = L_Heap;
#[doc = " \\file list.h"]
#[doc = ""]
#[doc = " <pre>"]
#[doc = "       Cell for double-linked lists"]
#[doc = ""]
#[doc = "       This allows composition of a list of cells with"]
#[doc = "           prev, next and data pointers.  Generic data"]
#[doc = "           structures hang on the list cell data pointers."]
#[doc = ""]
#[doc = "       The list is not circular because that would add much"]
#[doc = "           complexity in traversing the list under general"]
#[doc = "           conditions where list cells can be added and removed."]
#[doc = "           The only disadvantage of not having the head point to"]
#[doc = "           the last cell is that the list must be traversed to"]
#[doc = "           find its tail.  However, this traversal is fast, and"]
#[doc = "           the listRemoveFromTail() function updates the tail"]
#[doc = "           so there is no searching overhead with repeated use."]
#[doc = ""]
#[doc = "       The list macros are used to run through a list, and their"]
#[doc = "       use is encouraged.  They are invoked, e.g., as"]
#[doc = ""]
#[doc = "             DLLIST  *head, *elem;"]
#[doc = "             ..."]
#[doc = "             L_BEGIN_LIST_FORWARD(head, elem)"]
#[doc = "                 <do something with elem and/or elem->data >"]
#[doc = "             L_END_LIST"]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoubleLinkedList {
    pub prev: *mut DoubleLinkedList,
    pub next: *mut DoubleLinkedList,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DoubleLinkedList() {
    assert_eq!(
        ::std::mem::size_of::<DoubleLinkedList>(),
        24usize,
        concat!("Size of: ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        ::std::mem::align_of::<DoubleLinkedList>(),
        8usize,
        concat!("Alignment of ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(data)
        )
    );
}
pub type DLLIST = DoubleLinkedList;
extern "C" {
    pub static MaxInitPtraSize: l_uint32;
}
#[doc = " Generic pointer array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptra {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< greatest valid index"]
    pub imax: l_int32,
    #[doc = "< actual number of stored elements"]
    pub nactual: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_L_Ptra() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptra>(),
        24usize,
        concat!("Size of: ", stringify!(L_Ptra))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptra>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptra))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).imax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(imax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).nactual as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nactual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(array)
        )
    );
}
pub type L_PTRA = L_Ptra;
#[doc = " Array of generic pointer arrays"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptraa {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< array of ptra"]
    pub ptra: *mut *mut L_Ptra,
}
#[test]
fn bindgen_test_layout_L_Ptraa() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptraa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Ptraa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptraa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptraa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptraa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptraa>())).ptra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(ptra)
        )
    );
}
pub type L_PTRAA = L_Ptraa;
#[doc = "< null the pointer only"]
pub const L_NO_COMPACTION: ::std::os::raw::c_uint = 1;
#[doc = "< compact the array"]
pub const L_COMPACTION: ::std::os::raw::c_uint = 2;
#[doc = " Ptra Removal"]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = "< choose based on number of holes"]
pub const L_AUTO_DOWNSHIFT: ::std::os::raw::c_uint = 0;
#[doc = "< downshifts min # of ptrs below insert"]
pub const L_MIN_DOWNSHIFT: ::std::os::raw::c_uint = 1;
#[doc = "< downshifts all ptrs below insert"]
pub const L_FULL_DOWNSHIFT: ::std::os::raw::c_uint = 2;
#[doc = " Ptra Insertion"]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[doc = "< ptr to L_Ptra; caller can inspect only"]
pub const L_HANDLE_ONLY: ::std::os::raw::c_uint = 0;
#[doc = "< caller owns; destroy or save in L_Ptraa"]
pub const L_REMOVE: ::std::os::raw::c_uint = 1;
#[doc = " Ptraa Accessor"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[doc = " Expandable pointer queue for arbitrary void* data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Queue {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< location of head (in ptrs) from the    */"]
    pub nhead: l_int32,
    #[doc = "< number of elements stored in the queue"]
    pub nelem: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
    #[doc = "< auxiliary stack"]
    pub stack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Queue() {
    assert_eq!(
        ::std::mem::size_of::<L_Queue>(),
        32usize,
        concat!("Size of: ", stringify!(L_Queue))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Queue>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nhead as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nelem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nelem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).stack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(stack)
        )
    );
}
pub type L_QUEUE = L_Queue;
pub const L_INT_TYPE: ::std::os::raw::c_uint = 1;
pub const L_UINT_TYPE: ::std::os::raw::c_uint = 2;
pub const L_FLOAT_TYPE: ::std::os::raw::c_uint = 3;
#[doc = " The three valid key types for red-black trees, maps and sets. */"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[doc = " Storage for keys and values for red-black trees, maps and sets."]
#[doc = " <pre>"]
#[doc = " Note:"]
#[doc = "   (1) Keys and values of the valid key types are all 64-bit"]
#[doc = "   (2) (void *) can be used for values but not for keys."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rb_Type {
    pub itype: l_int64,
    pub utype: l_uint64,
    pub ftype: l_float64,
    pub ptype: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Rb_Type() {
    assert_eq!(
        ::std::mem::size_of::<Rb_Type>(),
        8usize,
        concat!("Size of: ", stringify!(Rb_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<Rb_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(Rb_Type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).itype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).utype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(utype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).ftype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).ptype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ptype)
        )
    );
}
pub type RB_TYPE = Rb_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rbtree {
    pub root: *mut L_Rbtree_Node,
    pub keytype: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree>(),
        16usize,
        concat!("Size of: ", stringify!(L_Rbtree))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree>())).keytype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(keytype)
        )
    );
}
pub type L_RBTREE = L_Rbtree;
pub type L_AMAP = L_Rbtree;
pub type L_ASET = L_Rbtree;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct L_Rbtree_Node {
    pub key: Rb_Type,
    pub value: Rb_Type,
    pub left: *mut L_Rbtree_Node,
    pub right: *mut L_Rbtree_Node,
    pub parent: *mut L_Rbtree_Node,
    pub color: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree_Node() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree_Node>(),
        48usize,
        concat!("Size of: ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree_Node>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).color as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(color)
        )
    );
}
pub type L_RBTREE_NODE = L_Rbtree_Node;
pub type L_AMAP_NODE = L_Rbtree_Node;
pub type L_ASET_NODE = L_Rbtree_Node;
#[doc = " Expandable pointer stack for arbitrary void* data."]
#[doc = " Note that array[n] is the first null ptr in the array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Stack {
    #[doc = "< size of ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of stored elements"]
    pub n: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
    #[doc = "< auxiliary stack"]
    pub auxstack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Stack() {
    assert_eq!(
        ::std::mem::size_of::<L_Stack>(),
        24usize,
        concat!("Size of: ", stringify!(L_Stack))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Stack>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).auxstack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(auxstack)
        )
    );
}
pub type L_STACK = L_Stack;
#[doc = "< tab or space at beginning of line"]
pub const SPLIT_ON_LEADING_WHITE: ::std::os::raw::c_uint = 1;
#[doc = "< newline with optional white space"]
pub const SPLIT_ON_BLANK_LINE: ::std::os::raw::c_uint = 2;
#[doc = "< leading white space or newline"]
pub const SPLIT_ON_BOTH: ::std::os::raw::c_uint = 3;
#[doc = " Constants for deciding when text block is divided into paragraphs */"]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[doc = " Data structure to hold bitmap fonts and related data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bmf {
    #[doc = "< pixa of bitmaps for 93 characters"]
    pub pixa: *mut Pixa,
    #[doc = "< font size (in points at 300 ppi)"]
    pub size: l_int32,
    #[doc = "< directory containing font bitmaps"]
    pub directory: *mut ::std::os::raw::c_char,
    #[doc = "< baseline offset for ascii 33 - 57"]
    pub baseline1: l_int32,
    #[doc = "< baseline offset for ascii 58 - 91"]
    pub baseline2: l_int32,
    #[doc = "< baseline offset for ascii 93 - 126"]
    pub baseline3: l_int32,
    #[doc = "< max height of line of chars"]
    pub lineheight: l_int32,
    #[doc = "< pixel dist between char bitmaps"]
    pub kernwidth: l_int32,
    #[doc = "< pixel dist between word bitmaps"]
    pub spacewidth: l_int32,
    #[doc = "< extra vertical space between text lines"]
    pub vertlinesep: l_int32,
    #[doc = "< table mapping ascii --> font index"]
    pub fonttab: *mut l_int32,
    #[doc = "< table mapping ascii --> baseline offset"]
    pub baselinetab: *mut l_int32,
    #[doc = "< table mapping ascii --> char width"]
    pub widthtab: *mut l_int32,
}
#[test]
fn bindgen_test_layout_L_Bmf() {
    assert_eq!(
        ::std::mem::size_of::<L_Bmf>(),
        80usize,
        concat!("Size of: ", stringify!(L_Bmf))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bmf>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bmf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).pixa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).directory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(directory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline3 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).lineheight as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(lineheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).kernwidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(kernwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).spacewidth as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(spacewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).vertlinesep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(vertlinesep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).fonttab as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(fonttab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baselinetab as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baselinetab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).widthtab as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(widthtab)
        )
    );
}
pub type L_BMF = L_Bmf;
pub const CCB_LOCAL_COORDS: ::std::os::raw::c_uint = 1;
pub const CCB_GLOBAL_COORDS: ::std::os::raw::c_uint = 2;
#[doc = " Use in ccbaStepChainsToPixCoords() */"]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const CCB_SAVE_ALL_PTS: ::std::os::raw::c_uint = 1;
pub const CCB_SAVE_TURNING_PTS: ::std::os::raw::c_uint = 2;
#[doc = " Use in ccbaGenerateSPGlobalLocs() */"]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[doc = " <pre>"]
#[doc = " CCBord contains:"]
#[doc = ""]
#[doc = "    (1) a minimally-clipped bitmap of the component (pix),"]
#[doc = "    (2) a boxa consisting of:"]
#[doc = "          for the primary component:"]
#[doc = "                (xul, yul) pixel location in global coords"]
#[doc = "                (w, h) of the bitmap"]
#[doc = "          for the hole components:"]
#[doc = "                (x, y) in relative coordinates in primary component"]
#[doc = "                (w, h) of the hole border (which is 2 pixels"]
#[doc = "                       larger in each direction than the hole itself)"]
#[doc = "    (3) a pta ('start') of the initial border pixel location for each"]
#[doc = "        closed curve, all in relative coordinates of the primary"]
#[doc = "        component.  This is given for the primary component,"]
#[doc = "        followed by the hole components, if any."]
#[doc = "    (4) a refcount of the ccbord; used internally when a ccbord"]
#[doc = "        is accessed from a ccborda (array of ccbord)"]
#[doc = "    (5) a ptaa for the chain code for the border in relative"]
#[doc = "        coordinates, where the first pta is the exterior border"]
#[doc = "        and all other pta are for interior borders (holes)"]
#[doc = "    (6) a ptaa for the global pixel loc rendition of the border,"]
#[doc = "        where the first pta is the exterior border and all other"]
#[doc = "        pta are for interior borders (holes)."]
#[doc = "        This is derived from the local or step chain code."]
#[doc = "    (7) a numaa for the chain code for the border as orientation"]
#[doc = "        directions between successive border pixels, where"]
#[doc = "        the first numa is the exterior border and all other"]
#[doc = "        numa are for interior borders (holes).  This is derived"]
#[doc = "        from the local chain code.  The 8 directions are 0 - 7."]
#[doc = "    (8) a pta for a single chain for each c.c., comprised of outer"]
#[doc = "        and hole borders, plus cut paths between them, all in"]
#[doc = "        local coords."]
#[doc = "    (9) a pta for a single chain for each c.c., comprised of outer"]
#[doc = "        and hole borders, plus cut paths between them, all in"]
#[doc = "        global coords."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBord {
    #[doc = "< component bitmap (min size)"]
    pub pix: *mut Pix,
    #[doc = "< regions of each closed curve"]
    pub boxa: *mut Boxa,
    #[doc = "< initial border pixel locations"]
    pub start: *mut Pta,
    #[doc = "< number of handles; start at 1"]
    pub refcount: l_int32,
    #[doc = "< ptaa of chain pixels (local)"]
    pub local: *mut Ptaa,
    #[doc = "< ptaa of chain pixels (global)"]
    pub global: *mut Ptaa,
    #[doc = "< numaa of chain code (step dir)"]
    pub step: *mut Numaa,
    #[doc = "< pta of single chain (local)"]
    pub splocal: *mut Pta,
    #[doc = "< pta of single chain (global)"]
    pub spglobal: *mut Pta,
}
#[test]
fn bindgen_test_layout_CCBord() {
    assert_eq!(
        ::std::mem::size_of::<CCBord>(),
        72usize,
        concat!("Size of: ", stringify!(CCBord))
    );
    assert_eq!(
        ::std::mem::align_of::<CCBord>(),
        8usize,
        concat!("Alignment of ", stringify!(CCBord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).boxa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).refcount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).local as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).global as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).step as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).splocal as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(splocal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).spglobal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(spglobal)
        )
    );
}
pub type CCBORD = CCBord;
#[doc = " Array of CCBord"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBorda {
    #[doc = "< input pix (may be null)"]
    pub pix: *mut Pix,
    #[doc = "< width of pix"]
    pub w: l_int32,
    #[doc = "< height of pix"]
    pub h: l_int32,
    #[doc = "< number of ccbord in ptr array"]
    pub n: l_int32,
    #[doc = "< number of ccbord ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< ccb ptr array"]
    pub ccb: *mut *mut CCBord,
}
#[test]
fn bindgen_test_layout_CCBorda() {
    assert_eq!(
        ::std::mem::size_of::<CCBorda>(),
        32usize,
        concat!("Size of: ", stringify!(CCBorda))
    );
    assert_eq!(
        ::std::mem::align_of::<CCBorda>(),
        8usize,
        concat!("Alignment of ", stringify!(CCBorda))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).nalloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).ccb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(ccb)
        )
    );
}
pub type CCBORDA = CCBorda;
#[doc = " Colorfill data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Colorfill {
    #[doc = "< clone of source pix"]
    pub pixs: *mut Pix,
    #[doc = "< source pix, after optional transform"]
    pub pixst: *mut Pix,
    #[doc = "< number of tiles in each tile row"]
    pub nx: l_int32,
    #[doc = "< number of tiles in each tile column"]
    pub ny: l_int32,
    #[doc = "< width of each tile"]
    pub tw: l_int32,
    #[doc = "< height of each tile"]
    pub th: l_int32,
    #[doc = "< min number of pixels in a color region"]
    pub minarea: l_int32,
    #[doc = "< tile locations"]
    pub boxas: *mut Boxa,
    #[doc = "< tiles from source pix"]
    pub pixas: *mut Pixa,
    #[doc = "< mask tiles with components covering    */"]
    pub pixam: *mut Pixa,
    #[doc = "< sizes of color regions (in pixels)"]
    pub naa: *mut Numaa,
    #[doc = "< average color in each region"]
    pub dnaa: *mut L_Dnaa,
    #[doc = "< debug reconstruction from segmentation"]
    pub pixadb: *mut Pixa,
}
#[test]
fn bindgen_test_layout_L_Colorfill() {
    assert_eq!(
        ::std::mem::size_of::<L_Colorfill>(),
        88usize,
        concat!("Size of: ", stringify!(L_Colorfill))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Colorfill>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Colorfill))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).nx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).ny as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).tw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(tw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).th as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).minarea as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(minarea)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).boxas as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(boxas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixas as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixam as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).naa as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(naa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).dnaa as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(dnaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixadb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixadb)
        )
    );
}
pub type L_COLORFILL = L_Colorfill;
#[doc = " Data structure to hold a number of Dewarp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarpa {
    #[doc = "< size of dewarp ptr array"]
    pub nalloc: l_int32,
    #[doc = "< maximum page number in array"]
    pub maxpage: l_int32,
    #[doc = "< array of ptrs to page dewarp"]
    pub dewarp: *mut *mut L_Dewarp,
    #[doc = "< array of ptrs to cached dewarps"]
    pub dewarpcache: *mut *mut L_Dewarp,
    #[doc = "< list of page numbers for pages    */"]
    pub namodels: *mut Numa,
    #[doc = "< list of page numbers with either  */"]
    pub napages: *mut Numa,
    #[doc = "< reduction factor of input: 1 or 2"]
    pub redfactor: l_int32,
    #[doc = "< disparity arrays sampling factor"]
    pub sampling: l_int32,
    #[doc = "< min number of long lines required"]
    pub minlines: l_int32,
    #[doc = "< max distance for getting ref page"]
    pub maxdist: l_int32,
    #[doc = "< maximum abs line curvature,       */"]
    pub max_linecurv: l_int32,
    #[doc = "< minimum abs diff line         */"]
    pub min_diff_linecurv: l_int32,
    #[doc = "< maximum abs diff line         */"]
    pub max_diff_linecurv: l_int32,
    #[doc = "< maximum abs left or right edge    */"]
    pub max_edgeslope: l_int32,
    #[doc = "< maximum abs left or right edge    */"]
    pub max_edgecurv: l_int32,
    #[doc = "< maximum abs diff left-right   */"]
    pub max_diff_edgecurv: l_int32,
    #[doc = "< use both disparity arrays if      */"]
    pub useboth: l_int32,
    #[doc = "< if there are multiple columns,    */"]
    pub check_columns: l_int32,
    #[doc = "< invalid models have been removed  */"]
    pub modelsready: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarpa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarpa>(),
        96usize,
        concat!("Size of: ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarpa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).maxpage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).dewarp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).dewarpcache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarpcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).namodels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(namodels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).napages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(napages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).redfactor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).sampling as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).minlines as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).maxdist as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxdist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_linecurv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).min_diff_linecurv as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(min_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_diff_linecurv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_edgeslope as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgeslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_edgecurv as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_diff_edgecurv as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_edgecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).useboth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(useboth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).check_columns as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(check_columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).modelsready as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(modelsready)
        )
    );
}
pub type L_DEWARPA = L_Dewarpa;
#[doc = " Data structure for a single dewarp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarp {
    #[doc = "< ptr to parent (not owned)"]
    pub dewa: *mut L_Dewarpa,
    #[doc = "< source pix, 1 bpp"]
    pub pixs: *mut Pix,
    #[doc = "< sampled vert disparity array"]
    pub sampvdispar: *mut FPix,
    #[doc = "< sampled horiz disparity array"]
    pub samphdispar: *mut FPix,
    #[doc = "< sampled slope h-disparity array"]
    pub sampydispar: *mut FPix,
    #[doc = "< full vert disparity array"]
    pub fullvdispar: *mut FPix,
    #[doc = "< full horiz disparity array"]
    pub fullhdispar: *mut FPix,
    #[doc = "< full slope h-disparity array"]
    pub fullydispar: *mut FPix,
    #[doc = "< sorted y val of midpoint each line"]
    pub namidys: *mut Numa,
    #[doc = "< sorted curvature of each line"]
    pub nacurves: *mut Numa,
    #[doc = "< width of source image"]
    pub w: l_int32,
    #[doc = "< height of source image"]
    pub h: l_int32,
    #[doc = "< page number; important for reuse"]
    pub pageno: l_int32,
    #[doc = "< sampling factor of disparity arrays"]
    pub sampling: l_int32,
    #[doc = "< reduction factor of pixs: 1 or 2"]
    pub redfactor: l_int32,
    #[doc = "< min number of long lines required"]
    pub minlines: l_int32,
    #[doc = "< number of long lines found"]
    pub nlines: l_int32,
    #[doc = "< min line curvature in micro-units"]
    pub mincurv: l_int32,
    #[doc = "< max line curvature in micro-units"]
    pub maxcurv: l_int32,
    #[doc = "< left edge slope in milli-units"]
    pub leftslope: l_int32,
    #[doc = "< right edge slope in milli-units"]
    pub rightslope: l_int32,
    #[doc = "< left edge curvature in micro-units"]
    pub leftcurv: l_int32,
    #[doc = "< right edge curvature in micro-units"]
    pub rightcurv: l_int32,
    #[doc = "< number of sampling pts in x-dir"]
    pub nx: l_int32,
    #[doc = "< number of sampling pts in y-dir"]
    pub ny: l_int32,
    #[doc = "< 0 if normal; 1 if has a refpage"]
    pub hasref: l_int32,
    #[doc = "< page with disparity model to use"]
    pub refpage: l_int32,
    #[doc = "< sets to 1 if vert disparity builds"]
    pub vsuccess: l_int32,
    #[doc = "< sets to 1 if horiz disparity builds"]
    pub hsuccess: l_int32,
    #[doc = "< sets to 1 if slope disparity builds"]
    pub ysuccess: l_int32,
    #[doc = "< sets to 1 if valid vert disparity"]
    pub vvalid: l_int32,
    #[doc = "< sets to 1 if valid horiz disparity"]
    pub hvalid: l_int32,
    #[doc = "< if 1, skip horiz disparity         */"]
    pub skip_horiz: l_int32,
    #[doc = "< set to 1 if debug output requested"]
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarp() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarp>(),
        176usize,
        concat!("Size of: ", stringify!(L_Dewarp))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarp>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).dewa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(dewa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).pixs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampvdispar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampvdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).samphdispar as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(samphdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampydispar as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampydispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullvdispar as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullvdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullhdispar as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullhdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullydispar as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullydispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).namidys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(namidys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nacurves as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nacurves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).w as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).h as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).pageno as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pageno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampling as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).redfactor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).minlines as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nlines as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).mincurv as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(mincurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).maxcurv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(maxcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).leftslope as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).rightslope as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).leftcurv as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).rightcurv as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nx as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).ny as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hasref as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hasref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).refpage as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(refpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).vsuccess as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vsuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hsuccess as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hsuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).ysuccess as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ysuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).vvalid as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hvalid as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).skip_horiz as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(skip_horiz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).debug as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(debug)
        )
    );
}
pub type L_DEWARP = L_Dewarp;
pub const GPLOT_STYLE_GPLOT_LINES: GPLOT_STYLE = 0;
pub const GPLOT_STYLE_GPLOT_POINTS: GPLOT_STYLE = 1;
pub const GPLOT_STYLE_GPLOT_IMPULSES: GPLOT_STYLE = 2;
pub const GPLOT_STYLE_GPLOT_LINESPOINTS: GPLOT_STYLE = 3;
pub const GPLOT_STYLE_GPLOT_DOTS: GPLOT_STYLE = 4;
pub type GPLOT_STYLE = ::std::os::raw::c_uint;
pub const GPLOT_OUTPUT_GPLOT_NONE: GPLOT_OUTPUT = 0;
pub const GPLOT_OUTPUT_GPLOT_PNG: GPLOT_OUTPUT = 1;
pub const GPLOT_OUTPUT_GPLOT_PS: GPLOT_OUTPUT = 2;
pub const GPLOT_OUTPUT_GPLOT_EPS: GPLOT_OUTPUT = 3;
pub const GPLOT_OUTPUT_GPLOT_LATEX: GPLOT_OUTPUT = 4;
pub const GPLOT_OUTPUT_GPLOT_PNM: GPLOT_OUTPUT = 5;
pub type GPLOT_OUTPUT = ::std::os::raw::c_uint;
#[doc = "< default"]
pub const GPLOT_SCALING_GPLOT_LINEAR_SCALE: GPLOT_SCALING = 0;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X: GPLOT_SCALING = 1;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_Y: GPLOT_SCALING = 2;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X_Y: GPLOT_SCALING = 3;
pub type GPLOT_SCALING = ::std::os::raw::c_uint;
extern "C" {
    pub static mut gplotstylenames: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut gplotfileoutputs: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " Data structure for generating gnuplot files"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPlot {
    #[doc = "< for cmd, data, output"]
    pub rootname: *mut ::std::os::raw::c_char,
    #[doc = "< command file name"]
    pub cmdname: *mut ::std::os::raw::c_char,
    #[doc = "< command file contents"]
    pub cmddata: *mut Sarray,
    #[doc = "< data file names"]
    pub datanames: *mut Sarray,
    #[doc = "< plot data (1 string/file)"]
    pub plotdata: *mut Sarray,
    #[doc = "< label for each individual plot"]
    pub plotlabels: *mut Sarray,
    #[doc = "< plot style for individual plots"]
    pub plotstyles: *mut Numa,
    #[doc = "< current number of plots"]
    pub nplots: l_int32,
    #[doc = "< output file name"]
    pub outname: *mut ::std::os::raw::c_char,
    #[doc = "< GPLOT_OUTPUT values"]
    pub outformat: l_int32,
    #[doc = "< GPLOT_SCALING values"]
    pub scaling: l_int32,
    #[doc = "< optional"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = "< optional x axis label"]
    pub xlabel: *mut ::std::os::raw::c_char,
    #[doc = "< optional y axis label"]
    pub ylabel: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GPlot() {
    assert_eq!(
        ::std::mem::size_of::<GPlot>(),
        104usize,
        concat!("Size of: ", stringify!(GPlot))
    );
    assert_eq!(
        ::std::mem::align_of::<GPlot>(),
        8usize,
        concat!("Alignment of ", stringify!(GPlot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).rootname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(rootname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).cmdname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmdname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).cmddata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmddata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).datanames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(datanames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotdata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotlabels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotlabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotstyles as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).nplots as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(nplots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).outname as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).outformat as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).scaling as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).title as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).xlabel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(xlabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).ylabel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(ylabel)
        )
    );
}
pub type GPLOT = GPlot;
pub const IFF_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const IFF_BMP: ::std::os::raw::c_uint = 1;
pub const IFF_JFIF_JPEG: ::std::os::raw::c_uint = 2;
pub const IFF_PNG: ::std::os::raw::c_uint = 3;
pub const IFF_TIFF: ::std::os::raw::c_uint = 4;
pub const IFF_TIFF_PACKBITS: ::std::os::raw::c_uint = 5;
pub const IFF_TIFF_RLE: ::std::os::raw::c_uint = 6;
pub const IFF_TIFF_G3: ::std::os::raw::c_uint = 7;
pub const IFF_TIFF_G4: ::std::os::raw::c_uint = 8;
pub const IFF_TIFF_LZW: ::std::os::raw::c_uint = 9;
pub const IFF_TIFF_ZIP: ::std::os::raw::c_uint = 10;
pub const IFF_PNM: ::std::os::raw::c_uint = 11;
pub const IFF_PS: ::std::os::raw::c_uint = 12;
pub const IFF_GIF: ::std::os::raw::c_uint = 13;
pub const IFF_JP2: ::std::os::raw::c_uint = 14;
pub const IFF_WEBP: ::std::os::raw::c_uint = 15;
pub const IFF_LPDF: ::std::os::raw::c_uint = 16;
pub const IFF_TIFF_JPEG: ::std::os::raw::c_uint = 17;
pub const IFF_DEFAULT: ::std::os::raw::c_uint = 18;
pub const IFF_SPIX: ::std::os::raw::c_uint = 19;
#[doc = " Image Formats"]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[doc = "< BM - for bitmaps"]
pub const BMP_ID: ::std::os::raw::c_uint = 19778;
#[doc = "< MM - for 'motorola'"]
pub const TIFF_BIGEND_ID: ::std::os::raw::c_uint = 19789;
#[doc = "< II - for 'intel'"]
pub const TIFF_LITTLEEND_ID: ::std::os::raw::c_uint = 18761;
#[doc = " Header Ids"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[doc = "< only want luminance data; no chroma"]
pub const L_JPEG_READ_LUMINANCE: ::std::os::raw::c_uint = 1;
#[doc = "< return possibly damaged pix"]
pub const L_JPEG_CONTINUE_WITH_BAD_DATA: ::std::os::raw::c_uint = 2;
#[doc = " Jpeg Hints"]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[doc = "< codestream"]
pub const L_J2K_CODEC: ::std::os::raw::c_uint = 1;
#[doc = "< file format with 'ihdr'"]
pub const L_JP2_CODEC: ::std::os::raw::c_uint = 2;
#[doc = " Jp2k Codecs"]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[doc = "< use default encoding based on image"]
pub const L_DEFAULT_ENCODE: ::std::os::raw::c_uint = 0;
#[doc = "< use dct encoding: 8 and 32 bpp, no cmap"]
pub const L_JPEG_ENCODE: ::std::os::raw::c_uint = 1;
#[doc = "< use ccitt g4 fax encoding: 1 bpp"]
pub const L_G4_ENCODE: ::std::os::raw::c_uint = 2;
#[doc = "< use flate encoding: any depth, cmap ok"]
pub const L_FLATE_ENCODE: ::std::os::raw::c_uint = 3;
#[doc = "< use jp2k encoding: 8 and 32 bpp, no cmap"]
pub const L_JP2K_ENCODE: ::std::os::raw::c_uint = 4;
#[doc = " Pdf Encoding"]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
#[doc = " Compressed image data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Compressed_Data {
    #[doc = "< encoding type: L_JPEG_ENCODE, etc"]
    pub type_: l_int32,
    #[doc = "< gzipped raster data"]
    pub datacomp: *mut l_uint8,
    #[doc = "< number of compressed bytes"]
    pub nbytescomp: size_t,
    #[doc = "< ascii85-encoded gzipped raster data"]
    pub data85: *mut ::std::os::raw::c_char,
    #[doc = "< number of ascii85 encoded bytes"]
    pub nbytes85: size_t,
    #[doc = "< ascii85-encoded uncompressed cmap"]
    pub cmapdata85: *mut ::std::os::raw::c_char,
    #[doc = "< hex pdf array for the cmap"]
    pub cmapdatahex: *mut ::std::os::raw::c_char,
    #[doc = "< number of colors in cmap"]
    pub ncolors: l_int32,
    #[doc = "< image width"]
    pub w: l_int32,
    #[doc = "< image height"]
    pub h: l_int32,
    #[doc = "< bits/sample; typ. 1, 2, 4 or 8"]
    pub bps: l_int32,
    #[doc = "< samples/pixel; typ. 1 or 3"]
    pub spp: l_int32,
    #[doc = "< tiff g4 photometry"]
    pub minisblack: l_int32,
    #[doc = "< flate data has PNG predictors"]
    pub predictor: l_int32,
    #[doc = "< number of uncompressed raster bytes"]
    pub nbytes: size_t,
    #[doc = "< resolution (ppi)"]
    pub res: l_int32,
}
#[test]
fn bindgen_test_layout_L_Compressed_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Compressed_Data>(),
        104usize,
        concat!("Size of: ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Compressed_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).datacomp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(datacomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytescomp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytescomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).data85 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(data85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytes85 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).cmapdata85 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdata85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).cmapdatahex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdatahex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).ncolors as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).w as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).h as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).bps as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).spp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(spp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).minisblack as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(minisblack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).predictor as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(predictor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).res as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(res)
        )
    );
}
pub type L_COMP_DATA = L_Compressed_Data;
#[doc = "< first image to be used"]
pub const L_FIRST_IMAGE: ::std::os::raw::c_uint = 1;
#[doc = "< intermediate image; not first or last"]
pub const L_NEXT_IMAGE: ::std::os::raw::c_uint = 2;
#[doc = "< last image to be used"]
pub const L_LAST_IMAGE: ::std::os::raw::c_uint = 3;
#[doc = " Pdf MultiImage"]
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[doc = " Intermediate pdf generation data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Pdf_Data {
    #[doc = "< optional title for pdf"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = "< number of images"]
    pub n: l_int32,
    #[doc = "< number of colormaps"]
    pub ncmap: l_int32,
    #[doc = "< array of compressed image data"]
    pub cida: *mut L_Ptra,
    #[doc = "< %PDF-1.2 id string"]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = "< catalog string"]
    pub obj1: *mut ::std::os::raw::c_char,
    #[doc = "< metadata string"]
    pub obj2: *mut ::std::os::raw::c_char,
    #[doc = "< pages string"]
    pub obj3: *mut ::std::os::raw::c_char,
    #[doc = "< page string (variable data)"]
    pub obj4: *mut ::std::os::raw::c_char,
    #[doc = "< content string (variable data)"]
    pub obj5: *mut ::std::os::raw::c_char,
    #[doc = "< post-binary-stream string"]
    pub poststream: *mut ::std::os::raw::c_char,
    #[doc = "< trailer string (variable data)"]
    pub trailer: *mut ::std::os::raw::c_char,
    #[doc = "< store (xpt, ypt) array"]
    pub xy: *mut Pta,
    #[doc = "< store (wpt, hpt) array"]
    pub wh: *mut Pta,
    #[doc = "< bounding region for all images"]
    pub mediabox: *mut Box,
    #[doc = "< pre-binary-stream xobject strings"]
    pub saprex: *mut Sarray,
    #[doc = "< colormap pdf object strings"]
    pub sacmap: *mut Sarray,
    #[doc = "< sizes of each pdf string object"]
    pub objsize: *mut L_Dna,
    #[doc = "< location of each pdf string object"]
    pub objloc: *mut L_Dna,
    #[doc = "< location of xref"]
    pub xrefloc: l_int32,
}
#[test]
fn bindgen_test_layout_L_Pdf_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Pdf_Data>(),
        152usize,
        concat!("Size of: ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Pdf_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).ncmap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(ncmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).cida as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(cida)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj4 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj5 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).poststream as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(poststream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).trailer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(trailer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).xy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).wh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(wh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).mediabox as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(mediabox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).saprex as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(saprex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).sacmap as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(sacmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).objsize as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).objloc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).xrefloc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xrefloc)
        )
    );
}
pub type L_PDF_DATA = L_Pdf_Data;
#[doc = " <pre>"]
#[doc = " The JbClasser struct holds all the data accumulated during the"]
#[doc = " classification process that can be used for a compressed"]
#[doc = " jbig2-type representation of a set of images.  This is created"]
#[doc = " in an initialization process and added to as the selected components"]
#[doc = " on each successive page are analyzed."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbClasser {
    #[doc = "< input page image file names"]
    pub safiles: *mut Sarray,
    #[doc = "< JB_RANKHAUS, JB_CORRELATION"]
    pub method: l_int32,
    #[doc = "< JB_CONN_COMPS, JB_CHARACTERS or      */"]
    pub components: l_int32,
    #[doc = "< max component width allowed"]
    pub maxwidth: l_int32,
    #[doc = "< max component height allowed"]
    pub maxheight: l_int32,
    #[doc = "< number of pages already processed"]
    pub npages: l_int32,
    #[doc = "< number components already processed  */"]
    pub baseindex: l_int32,
    #[doc = "< number of components on each page"]
    pub nacomps: *mut Numa,
    #[doc = "< size of square struct elem for haus"]
    pub sizehaus: l_int32,
    #[doc = "< rank val of haus match, each way"]
    pub rankhaus: l_float32,
    #[doc = "< thresh value for correlation score"]
    pub thresh: l_float32,
    #[doc = "< corrects thresh value for heaver     */"]
    pub weightfactor: l_float32,
    #[doc = "< w * h of each template, without      */"]
    pub naarea: *mut Numa,
    #[doc = "< max width of original src images"]
    pub w: l_int32,
    #[doc = "< max height of original src images"]
    pub h: l_int32,
    #[doc = "< current number of classes"]
    pub nclass: l_int32,
    #[doc = "< If zero, pixaa isn't filled"]
    pub keep_pixaa: l_int32,
    #[doc = "< instances for each class; unbordered"]
    pub pixaa: *mut Pixaa,
    #[doc = "< templates for each class; bordered   */"]
    pub pixat: *mut Pixa,
    #[doc = "< templates for each class; bordered   */"]
    pub pixatd: *mut Pixa,
    #[doc = "< Hash table to find templates by size"]
    pub dahash: *mut L_DnaHash,
    #[doc = "< fg areas of undilated templates;     */"]
    pub nafgt: *mut Numa,
    #[doc = "< centroids of all bordered cc"]
    pub ptac: *mut Pta,
    #[doc = "< centroids of all bordered template cc"]
    pub ptact: *mut Pta,
    #[doc = "< array of class ids for each component"]
    pub naclass: *mut Numa,
    #[doc = "< array of page nums for each component"]
    pub napage: *mut Numa,
    #[doc = "< array of UL corners at which the     */"]
    pub ptaul: *mut Pta,
    #[doc = "< similar to ptaul, but for LL corners"]
    pub ptall: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbClasser() {
    assert_eq!(
        ::std::mem::size_of::<JbClasser>(),
        168usize,
        concat!("Size of: ", stringify!(JbClasser))
    );
    assert_eq!(
        ::std::mem::align_of::<JbClasser>(),
        8usize,
        concat!("Alignment of ", stringify!(JbClasser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).safiles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(safiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).method as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).components as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).maxwidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).maxheight as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).npages as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).baseindex as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(baseindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nacomps as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nacomps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).sizehaus as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(sizehaus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).rankhaus as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(rankhaus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).thresh as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).weightfactor as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(weightfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).naarea as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naarea)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).w as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).h as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nclass as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).keep_pixaa as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(keep_pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixaa as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixatd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixatd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).dahash as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(dahash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nafgt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nafgt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptac as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptact as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).naclass as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).napage as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptaul as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptaul)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptall as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptall)
        )
    );
}
pub type JBCLASSER = JbClasser;
#[doc = " <pre>"]
#[doc = " The JbData struct holds all the data required for"]
#[doc = " the compressed jbig-type representation of a set of images."]
#[doc = " The data can be written to file, read back, and used"]
#[doc = " to regenerate an approximate version of the original,"]
#[doc = " which differs in two ways from the original:"]
#[doc = "   (1) It uses a template image for each c.c. instead of the"]
#[doc = "       original instance, for each occurrence on each page."]
#[doc = "   (2) It discards components with either a height or width larger"]
#[doc = "       than the maximuma, given here by the lattice dimensions"]
#[doc = "       used for storing the templates."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbData {
    #[doc = "< template composite for all classes"]
    pub pix: *mut Pix,
    #[doc = "< number of pages"]
    pub npages: l_int32,
    #[doc = "< max width of original page images"]
    pub w: l_int32,
    #[doc = "< max height of original page images"]
    pub h: l_int32,
    #[doc = "< number of classes"]
    pub nclass: l_int32,
    #[doc = "< lattice width for template composite"]
    pub latticew: l_int32,
    #[doc = "< lattice height for template composite"]
    pub latticeh: l_int32,
    #[doc = "< array of class ids for each component"]
    pub naclass: *mut Numa,
    #[doc = "< array of page nums for each component"]
    pub napage: *mut Numa,
    #[doc = "< array of UL corners at which the      */"]
    pub ptaul: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbData() {
    assert_eq!(
        ::std::mem::size_of::<JbData>(),
        56usize,
        concat!("Size of: ", stringify!(JbData))
    );
    assert_eq!(
        ::std::mem::align_of::<JbData>(),
        8usize,
        concat!("Alignment of ", stringify!(JbData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).npages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).h as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).nclass as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).latticew as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).latticeh as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticeh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).naclass as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).napage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).ptaul as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(ptaul)
        )
    );
}
pub type JBDATA = JbData;
pub const JB_RANKHAUS: ::std::os::raw::c_uint = 0;
pub const JB_CORRELATION: ::std::os::raw::c_uint = 1;
#[doc = " JB Classifier"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const JB_CONN_COMPS: ::std::os::raw::c_uint = 0;
pub const JB_CHARACTERS: ::std::os::raw::c_uint = 1;
pub const JB_WORDS: ::std::os::raw::c_uint = 2;
#[doc = " For jbGetComponents(): type of component to extract from images */"]
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[doc = " Selection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sel {
    #[doc = "< sel height"]
    pub sy: l_int32,
    #[doc = "< sel width"]
    pub sx: l_int32,
    #[doc = "< y location of sel origin"]
    pub cy: l_int32,
    #[doc = "< x location of sel origin"]
    pub cx: l_int32,
    #[doc = "< {0,1,2}; data[i][j] in [row][col] order"]
    pub data: *mut *mut l_int32,
    #[doc = "< used to find sel by name"]
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sel() {
    assert_eq!(
        ::std::mem::size_of::<Sel>(),
        32usize,
        concat!("Size of: ", stringify!(Sel))
    );
    assert_eq!(
        ::std::mem::align_of::<Sel>(),
        8usize,
        concat!("Alignment of ", stringify!(Sel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).sy as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).sx as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).cy as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).cx as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).name as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(name))
    );
}
pub type SEL = Sel;
#[doc = " Array of Sel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sela {
    #[doc = "< number of sel actually stored"]
    pub n: l_int32,
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< sel ptr array"]
    pub sel: *mut *mut Sel,
}
#[test]
fn bindgen_test_layout_Sela() {
    assert_eq!(
        ::std::mem::size_of::<Sela>(),
        16usize,
        concat!("Size of: ", stringify!(Sela))
    );
    assert_eq!(
        ::std::mem::align_of::<Sela>(),
        8usize,
        concat!("Alignment of ", stringify!(Sela))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Sela),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).sel as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(sel))
    );
}
pub type SELA = Sela;
#[doc = " Kernel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Kernel {
    #[doc = "< kernel height"]
    pub sy: l_int32,
    #[doc = "< kernel width"]
    pub sx: l_int32,
    #[doc = "< y location of kernel origin"]
    pub cy: l_int32,
    #[doc = "< x location of kernel origin"]
    pub cx: l_int32,
    #[doc = "< data[i][j] in [row][col] order"]
    pub data: *mut *mut l_float32,
}
#[test]
fn bindgen_test_layout_L_Kernel() {
    assert_eq!(
        ::std::mem::size_of::<L_Kernel>(),
        24usize,
        concat!("Size of: ", stringify!(L_Kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Kernel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).sy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).sx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).cy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).cx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(data)
        )
    );
}
pub type L_KERNEL = L_Kernel;
pub const SYMMETRIC_MORPH_BC: ::std::os::raw::c_uint = 0;
pub const ASYMMETRIC_MORPH_BC: ::std::os::raw::c_uint = 1;
#[doc = " Morph Boundary"]
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const SEL_DONT_CARE: ::std::os::raw::c_uint = 0;
pub const SEL_HIT: ::std::os::raw::c_uint = 1;
pub const SEL_MISS: ::std::os::raw::c_uint = 2;
#[doc = " SEL Vals"]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const L_RUN_OFF: ::std::os::raw::c_uint = 0;
pub const L_RUN_ON: ::std::os::raw::c_uint = 1;
#[doc = " Runlength Polarity"]
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const L_HORIZ: ::std::os::raw::c_uint = 1;
pub const L_VERT: ::std::os::raw::c_uint = 2;
pub const L_BOTH_DIRECTIONS: ::std::os::raw::c_uint = 3;
#[doc = " Direction Flags"]
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const L_MORPH_DILATE: ::std::os::raw::c_uint = 1;
pub const L_MORPH_ERODE: ::std::os::raw::c_uint = 2;
pub const L_MORPH_OPEN: ::std::os::raw::c_uint = 3;
pub const L_MORPH_CLOSE: ::std::os::raw::c_uint = 4;
pub const L_MORPH_HMT: ::std::os::raw::c_uint = 5;
#[doc = " Morph Operator"]
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const L_LINEAR_SCALE: ::std::os::raw::c_uint = 1;
pub const L_LOG_SCALE: ::std::os::raw::c_uint = 2;
#[doc = " Pixel Value Scaling"]
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const L_TOPHAT_WHITE: ::std::os::raw::c_uint = 0;
pub const L_TOPHAT_BLACK: ::std::os::raw::c_uint = 1;
#[doc = " Morph Tophat"]
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const L_ARITH_ADD: ::std::os::raw::c_uint = 1;
pub const L_ARITH_SUBTRACT: ::std::os::raw::c_uint = 2;
pub const L_ARITH_MULTIPLY: ::std::os::raw::c_uint = 3;
pub const L_ARITH_DIVIDE: ::std::os::raw::c_uint = 4;
pub const L_UNION: ::std::os::raw::c_uint = 5;
pub const L_INTERSECTION: ::std::os::raw::c_uint = 6;
pub const L_SUBTRACTION: ::std::os::raw::c_uint = 7;
pub const L_EXCLUSIVE_OR: ::std::os::raw::c_uint = 8;
#[doc = " ArithLogical Ops"]
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const L_CHOOSE_MIN: ::std::os::raw::c_uint = 1;
pub const L_CHOOSE_MAX: ::std::os::raw::c_uint = 2;
pub const L_CHOOSE_MAXDIFF: ::std::os::raw::c_uint = 3;
pub const L_CHOOSE_MIN_BOOST: ::std::os::raw::c_uint = 4;
pub const L_CHOOSE_MAX_BOOST: ::std::os::raw::c_uint = 5;
#[doc = " MinMax Selection"]
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const L_BOUNDARY_BG: ::std::os::raw::c_uint = 1;
pub const L_BOUNDARY_FG: ::std::os::raw::c_uint = 2;
#[doc = " Exterior Value"]
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const L_COMPARE_XOR: ::std::os::raw::c_uint = 1;
pub const L_COMPARE_SUBTRACT: ::std::os::raw::c_uint = 2;
pub const L_COMPARE_ABS_DIFF: ::std::os::raw::c_uint = 3;
#[doc = " Image Comparison"]
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const ADDED_BORDER: l_int32 = 32;
#[doc = " Basic Pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pix {
    #[doc = "< width in pixels"]
    pub w: l_uint32,
    #[doc = "< height in pixels"]
    pub h: l_uint32,
    #[doc = "< depth in bits (bpp)"]
    pub d: l_uint32,
    #[doc = "< number of samples per pixel"]
    pub spp: l_uint32,
    #[doc = "< 32-bit words/line"]
    pub wpl: l_uint32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< image res (ppi) in x direction    */"]
    pub xres: l_int32,
    #[doc = "< image res (ppi) in y direction    */"]
    pub yres: l_int32,
    #[doc = "< input file format, IFF_*"]
    pub informat: l_int32,
    #[doc = "< special instructions for I/O, etc"]
    pub special: l_int32,
    #[doc = "< text string associated with pix"]
    pub text: *mut ::std::os::raw::c_char,
    #[doc = "< colormap (may be null)"]
    pub colormap: *mut PixColormap,
    #[doc = "< the image data"]
    pub data: *mut l_uint32,
}
#[test]
fn bindgen_test_layout_Pix() {
    assert_eq!(
        ::std::mem::size_of::<Pix>(),
        64usize,
        concat!("Size of: ", stringify!(Pix))
    );
    assert_eq!(
        ::std::mem::align_of::<Pix>(),
        8usize,
        concat!("Alignment of ", stringify!(Pix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).d as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).spp as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(spp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).wpl as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).refcount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).xres as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(xres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).yres as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(yres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).informat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(informat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).special as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(special)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).text as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(text))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).colormap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).data as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(data))
    );
}
pub type PIX = Pix;
#[doc = " Colormap of a Pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixColormap {
    #[doc = "< colormap table (array of RGBA_QUAD)"]
    pub array: *mut ::std::os::raw::c_void,
    #[doc = "< of pix (1, 2, 4 or 8 bpp)"]
    pub depth: l_int32,
    #[doc = "< number of color entries allocated"]
    pub nalloc: l_int32,
    #[doc = "< number of color entries used"]
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_PixColormap() {
    assert_eq!(
        ::std::mem::size_of::<PixColormap>(),
        24usize,
        concat!("Size of: ", stringify!(PixColormap))
    );
    assert_eq!(
        ::std::mem::align_of::<PixColormap>(),
        8usize,
        concat!("Alignment of ", stringify!(PixColormap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).nalloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(n)
        )
    );
}
pub type PIXCMAP = PixColormap;
#[doc = " Colormap table entry (after the BMP version)."]
#[doc = " Note that the BMP format stores the colormap table exactly"]
#[doc = " as it appears here, with color samples being stored sequentially,"]
#[doc = " in the order (b,g,r,a)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBA_Quad {
    #[doc = "< blue value"]
    pub blue: l_uint8,
    #[doc = "< green value"]
    pub green: l_uint8,
    #[doc = "< red value"]
    pub red: l_uint8,
    #[doc = "< alpha value"]
    pub alpha: l_uint8,
}
#[test]
fn bindgen_test_layout_RGBA_Quad() {
    assert_eq!(
        ::std::mem::size_of::<RGBA_Quad>(),
        4usize,
        concat!("Size of: ", stringify!(RGBA_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<RGBA_Quad>(),
        1usize,
        concat!("Alignment of ", stringify!(RGBA_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).blue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).green as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).red as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).alpha as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(alpha)
        )
    );
}
pub type RGBA_QUAD = RGBA_Quad;
#[doc = "< red color index in RGBA_QUAD"]
pub const COLOR_RED: ::std::os::raw::c_uint = 0;
#[doc = "< green color index in RGBA_QUAD"]
pub const COLOR_GREEN: ::std::os::raw::c_uint = 1;
#[doc = "< blue color index in RGBA_QUAD"]
pub const COLOR_BLUE: ::std::os::raw::c_uint = 2;
#[doc = "< alpha value index in RGBA_QUAD"]
pub const L_ALPHA_CHANNEL: ::std::os::raw::c_uint = 3;
#[doc = " RGBA Color"]
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const L_RED_SHIFT: l_int32 = 24;
pub const L_GREEN_SHIFT: l_int32 = 16;
pub const L_BLUE_SHIFT: l_int32 = 8;
pub const L_ALPHA_SHIFT: l_int32 = 0;
#[doc = "< draw in red"]
pub const L_DRAW_RED: ::std::os::raw::c_uint = 0;
#[doc = "< draw in green"]
pub const L_DRAW_GREEN: ::std::os::raw::c_uint = 1;
#[doc = "< draw in blue"]
pub const L_DRAW_BLUE: ::std::os::raw::c_uint = 2;
#[doc = "< draw specified color"]
pub const L_DRAW_SPECIFIED: ::std::os::raw::c_uint = 3;
#[doc = "< draw as sequence of r,g,b"]
pub const L_DRAW_RGB: ::std::os::raw::c_uint = 4;
#[doc = "< draw randomly chosen colors"]
pub const L_DRAW_RANDOM: ::std::os::raw::c_uint = 5;
#[doc = " Box Color"]
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const L_RED_WEIGHT: l_float32 = 0.30000001192092896;
pub const L_GREEN_WEIGHT: l_float32 = 0.5;
pub const L_BLUE_WEIGHT: l_float32 = 0.20000000298023224;
#[doc = "< remove colormap for conv to 1 bpp"]
pub const REMOVE_CMAP_TO_BINARY: ::std::os::raw::c_uint = 0;
#[doc = "< remove colormap for conv to 8 bpp"]
pub const REMOVE_CMAP_TO_GRAYSCALE: ::std::os::raw::c_uint = 1;
#[doc = "< remove colormap for conv to 32 bpp"]
pub const REMOVE_CMAP_TO_FULL_COLOR: ::std::os::raw::c_uint = 2;
#[doc = "< remove colormap and alpha"]
pub const REMOVE_CMAP_WITH_ALPHA: ::std::os::raw::c_uint = 3;
#[doc = "< remove depending on src format"]
pub const REMOVE_CMAP_BASED_ON_SRC: ::std::os::raw::c_uint = 4;
#[doc = " Cmap Conversion"]
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
#[doc = " Array of pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixa {
    #[doc = "< number of Pix in ptr array"]
    pub n: l_int32,
    #[doc = "< number of Pix ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< the array of ptrs to pix"]
    pub pix: *mut *mut Pix,
    #[doc = "< array of boxes"]
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_Pixa() {
    assert_eq!(
        ::std::mem::size_of::<Pixa>(),
        32usize,
        concat!("Size of: ", stringify!(Pixa))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixa>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).pix as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pixa), "::", stringify!(pix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).boxa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXA = Pixa;
#[doc = " Array of arrays of pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixaa {
    #[doc = "< number of Pixa in ptr array"]
    pub n: l_int32,
    #[doc = "< number of Pixa ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< array of ptrs to pixa"]
    pub pixa: *mut *mut Pixa,
    #[doc = "< array of boxes"]
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_Pixaa() {
    assert_eq!(
        ::std::mem::size_of::<Pixaa>(),
        24usize,
        concat!("Size of: ", stringify!(Pixaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).pixa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).boxa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXAA = Pixaa;
#[doc = " Basic rectangle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Box {
    #[doc = "< left coordinate"]
    pub x: l_int32,
    #[doc = "< top coordinate"]
    pub y: l_int32,
    #[doc = "< box width"]
    pub w: l_int32,
    #[doc = "< box height"]
    pub h: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
}
#[test]
fn bindgen_test_layout_Box() {
    assert_eq!(
        ::std::mem::size_of::<Box>(),
        20usize,
        concat!("Size of: ", stringify!(Box))
    );
    assert_eq!(
        ::std::mem::align_of::<Box>(),
        4usize,
        concat!("Alignment of ", stringify!(Box))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).w as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).h as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Box),
            "::",
            stringify!(refcount)
        )
    );
}
pub type BOX = Box;
#[doc = " Array of Box"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxa {
    #[doc = "< number of box in ptr array"]
    pub n: l_int32,
    #[doc = "< number of box ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< box ptr array"]
    pub box_: *mut *mut Box,
}
#[test]
fn bindgen_test_layout_Boxa() {
    assert_eq!(
        ::std::mem::size_of::<Boxa>(),
        24usize,
        concat!("Size of: ", stringify!(Boxa))
    );
    assert_eq!(
        ::std::mem::align_of::<Boxa>(),
        8usize,
        concat!("Alignment of ", stringify!(Boxa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Boxa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).box_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(box_)
        )
    );
}
pub type BOXA = Boxa;
#[doc = " Array of Boxa"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxaa {
    #[doc = "< number of boxa in ptr array"]
    pub n: l_int32,
    #[doc = "< number of boxa ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< boxa ptr array"]
    pub boxa: *mut *mut Boxa,
}
#[test]
fn bindgen_test_layout_Boxaa() {
    assert_eq!(
        ::std::mem::size_of::<Boxaa>(),
        16usize,
        concat!("Size of: ", stringify!(Boxaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Boxaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Boxaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Boxaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).boxa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxaa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type BOXAA = Boxaa;
#[doc = " Array of points"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pta {
    #[doc = "< actual number of pts"]
    pub n: l_int32,
    #[doc = "< size of allocated arrays"]
    pub nalloc: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< arrays of floats"]
    pub x: *mut l_float32,
    #[doc = "< arrays of floats"]
    pub y: *mut l_float32,
}
#[test]
fn bindgen_test_layout_Pta() {
    assert_eq!(
        ::std::mem::size_of::<Pta>(),
        32usize,
        concat!("Size of: ", stringify!(Pta))
    );
    assert_eq!(
        ::std::mem::align_of::<Pta>(),
        8usize,
        concat!("Alignment of ", stringify!(Pta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pta),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pta),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).x as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).y as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(y))
    );
}
pub type PTA = Pta;
#[doc = " Array of Pta"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ptaa {
    #[doc = "< number of pta in ptr array"]
    pub n: l_int32,
    #[doc = "< number of pta ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< pta ptr array"]
    pub pta: *mut *mut Pta,
}
#[test]
fn bindgen_test_layout_Ptaa() {
    assert_eq!(
        ::std::mem::size_of::<Ptaa>(),
        16usize,
        concat!("Size of: ", stringify!(Ptaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Ptaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Ptaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ptaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ptaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).pta as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Ptaa), "::", stringify!(pta))
    );
}
pub type PTAA = Ptaa;
#[doc = " Pix accumulator container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixacc {
    #[doc = "< array width"]
    pub w: l_int32,
    #[doc = "< array height"]
    pub h: l_int32,
    #[doc = "< used to allow negative            */"]
    pub offset: l_int32,
    #[doc = "< the 32 bit accumulator pix"]
    pub pix: *mut Pix,
}
#[test]
fn bindgen_test_layout_Pixacc() {
    assert_eq!(
        ::std::mem::size_of::<Pixacc>(),
        24usize,
        concat!("Size of: ", stringify!(Pixacc))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixacc>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixacc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixacc), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pixacc), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixacc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).pix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixacc),
            "::",
            stringify!(pix)
        )
    );
}
pub type PIXACC = Pixacc;
#[doc = " Pix tiling"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixTiling {
    #[doc = "< input pix (a clone)"]
    pub pix: *mut Pix,
    #[doc = "< number of tiles horizontally"]
    pub nx: l_int32,
    #[doc = "< number of tiles vertically"]
    pub ny: l_int32,
    #[doc = "< tile width"]
    pub w: l_int32,
    #[doc = "< tile height"]
    pub h: l_int32,
    #[doc = "< overlap on left and right"]
    pub xoverlap: l_int32,
    #[doc = "< overlap on top and bottom"]
    pub yoverlap: l_int32,
    #[doc = "< strip for paint; default is TRUE"]
    pub strip: l_int32,
}
#[test]
fn bindgen_test_layout_PixTiling() {
    assert_eq!(
        ::std::mem::size_of::<PixTiling>(),
        40usize,
        concat!("Size of: ", stringify!(PixTiling))
    );
    assert_eq!(
        ::std::mem::align_of::<PixTiling>(),
        8usize,
        concat!("Alignment of ", stringify!(PixTiling))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).nx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).ny as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).xoverlap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(xoverlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).yoverlap as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(yoverlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).strip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(strip)
        )
    );
}
pub type PIXTILING = PixTiling;
#[doc = " Pix with float array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPix {
    #[doc = "< width in pixels"]
    pub w: l_int32,
    #[doc = "< height in pixels"]
    pub h: l_int32,
    #[doc = "< 32-bit words/line"]
    pub wpl: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< image res (ppi) in x direction    */"]
    pub xres: l_int32,
    #[doc = "< image res (ppi) in y direction    */"]
    pub yres: l_int32,
    #[doc = "< the float image data"]
    pub data: *mut l_float32,
}
#[test]
fn bindgen_test_layout_FPix() {
    assert_eq!(
        ::std::mem::size_of::<FPix>(),
        32usize,
        concat!("Size of: ", stringify!(FPix))
    );
    assert_eq!(
        ::std::mem::align_of::<FPix>(),
        8usize,
        concat!("Alignment of ", stringify!(FPix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).wpl as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).xres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).yres as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(data)
        )
    );
}
pub type FPIX = FPix;
#[doc = " Array of FPix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPixa {
    #[doc = "< number of fpix in ptr array"]
    pub n: l_int32,
    #[doc = "< number of fpix ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< the array of ptrs to fpix"]
    pub fpix: *mut *mut FPix,
}
#[test]
fn bindgen_test_layout_FPixa() {
    assert_eq!(
        ::std::mem::size_of::<FPixa>(),
        24usize,
        concat!("Size of: ", stringify!(FPixa))
    );
    assert_eq!(
        ::std::mem::align_of::<FPixa>(),
        8usize,
        concat!("Alignment of ", stringify!(FPixa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FPixa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).fpix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(fpix)
        )
    );
}
pub type FPIXA = FPixa;
#[doc = " Pix with double array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPix {
    #[doc = "< width in pixels"]
    pub w: l_int32,
    #[doc = "< height in pixels"]
    pub h: l_int32,
    #[doc = "< 32-bit words/line"]
    pub wpl: l_int32,
    #[doc = "< reference count (1 if no clones)"]
    pub refcount: l_uint32,
    #[doc = "< image res (ppi) in x direction    */"]
    pub xres: l_int32,
    #[doc = "< image res (ppi) in y direction    */"]
    pub yres: l_int32,
    #[doc = "< the double image data"]
    pub data: *mut l_float64,
}
#[test]
fn bindgen_test_layout_DPix() {
    assert_eq!(
        ::std::mem::size_of::<DPix>(),
        32usize,
        concat!("Size of: ", stringify!(DPix))
    );
    assert_eq!(
        ::std::mem::align_of::<DPix>(),
        8usize,
        concat!("Alignment of ", stringify!(DPix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).wpl as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).xres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).yres as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(data)
        )
    );
}
pub type DPIX = DPix;
#[doc = " Compressed Pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixComp {
    #[doc = "< width in pixels"]
    pub w: l_int32,
    #[doc = "< height in pixels"]
    pub h: l_int32,
    #[doc = "< depth in bits"]
    pub d: l_int32,
    #[doc = "< image res (ppi) in x direction    */"]
    pub xres: l_int32,
    #[doc = "< image res (ppi) in y direction    */"]
    pub yres: l_int32,
    #[doc = "< compressed format (IFF_TIFF_G4,   */"]
    pub comptype: l_int32,
    #[doc = "< text string associated with pix"]
    pub text: *mut ::std::os::raw::c_char,
    #[doc = "< flag (1 for cmap, 0 otherwise)"]
    pub cmapflag: l_int32,
    #[doc = "< the compressed image data"]
    pub data: *mut l_uint8,
    #[doc = "< size of the data array"]
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_PixComp() {
    assert_eq!(
        ::std::mem::size_of::<PixComp>(),
        56usize,
        concat!("Size of: ", stringify!(PixComp))
    );
    assert_eq!(
        ::std::mem::align_of::<PixComp>(),
        8usize,
        concat!("Alignment of ", stringify!(PixComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).xres as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).yres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).comptype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(comptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).text as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).cmapflag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(cmapflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(size)
        )
    );
}
pub type PIXC = PixComp;
#[doc = " Array of compressed pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixaComp {
    #[doc = "< number of PixComp in ptr array"]
    pub n: l_int32,
    #[doc = "< number of PixComp ptrs allocated"]
    pub nalloc: l_int32,
    #[doc = "< indexing offset into ptr array"]
    pub offset: l_int32,
    #[doc = "< the array of ptrs to PixComp"]
    pub pixc: *mut *mut PixComp,
    #[doc = "< array of boxes"]
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_PixaComp() {
    assert_eq!(
        ::std::mem::size_of::<PixaComp>(),
        32usize,
        concat!("Size of: ", stringify!(PixaComp))
    );
    assert_eq!(
        ::std::mem::align_of::<PixaComp>(),
        8usize,
        concat!("Alignment of ", stringify!(PixaComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).pixc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(pixc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).boxa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXAC = PixaComp;
#[doc = "< do not copy the object; do not delete the ptr"]
pub const L_NOCOPY: ::std::os::raw::c_uint = 0;
#[doc = "< stuff it in; do not copy or clone"]
pub const L_INSERT: ::std::os::raw::c_uint = 0;
#[doc = "< make/use a copy of the object"]
pub const L_COPY: ::std::os::raw::c_uint = 1;
#[doc = "< make/use clone (ref count) of the object"]
pub const L_CLONE: ::std::os::raw::c_uint = 2;
#[doc = "< make a new array object (e.g., pixa) and fill  */"]
pub const L_COPY_CLONE: ::std::os::raw::c_uint = 3;
#[doc = " Object Access"]
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
#[doc = "< use shell sort"]
pub const L_SHELL_SORT: ::std::os::raw::c_uint = 1;
#[doc = "< use bin sort"]
pub const L_BIN_SORT: ::std::os::raw::c_uint = 2;
#[doc = " Sort Mode"]
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
#[doc = "< sort in increasing order"]
pub const L_SORT_INCREASING: ::std::os::raw::c_uint = 1;
#[doc = "< sort in decreasing order"]
pub const L_SORT_DECREASING: ::std::os::raw::c_uint = 2;
#[doc = " Sort Order"]
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
#[doc = "< sort box or c.c. by left edge location"]
pub const L_SORT_BY_X: ::std::os::raw::c_uint = 1;
#[doc = "< sort box or c.c. by top edge location"]
pub const L_SORT_BY_Y: ::std::os::raw::c_uint = 2;
#[doc = "< sort box or c.c. by right edge location"]
pub const L_SORT_BY_RIGHT: ::std::os::raw::c_uint = 3;
#[doc = "< sort box or c.c. by bot edge location"]
pub const L_SORT_BY_BOT: ::std::os::raw::c_uint = 4;
#[doc = "< sort box or c.c. by width"]
pub const L_SORT_BY_WIDTH: ::std::os::raw::c_uint = 5;
#[doc = "< sort box or c.c. by height"]
pub const L_SORT_BY_HEIGHT: ::std::os::raw::c_uint = 6;
#[doc = "< sort box or c.c. by min dimension"]
pub const L_SORT_BY_MIN_DIMENSION: ::std::os::raw::c_uint = 7;
#[doc = "< sort box or c.c. by max dimension"]
pub const L_SORT_BY_MAX_DIMENSION: ::std::os::raw::c_uint = 8;
#[doc = "< sort box or c.c. by perimeter"]
pub const L_SORT_BY_PERIMETER: ::std::os::raw::c_uint = 9;
#[doc = "< sort box or c.c. by area"]
pub const L_SORT_BY_AREA: ::std::os::raw::c_uint = 10;
#[doc = "< sort box or c.c. by width/height ratio"]
pub const L_SORT_BY_ASPECT_RATIO: ::std::os::raw::c_uint = 11;
#[doc = " Sort Type"]
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
#[doc = "< add some of src inverse to itself"]
pub const L_BLEND_WITH_INVERSE: ::std::os::raw::c_uint = 1;
#[doc = "< shift src colors towards white"]
pub const L_BLEND_TO_WHITE: ::std::os::raw::c_uint = 2;
#[doc = "< shift src colors towards black"]
pub const L_BLEND_TO_BLACK: ::std::os::raw::c_uint = 3;
#[doc = "< blend src directly with blender"]
pub const L_BLEND_GRAY: ::std::os::raw::c_uint = 4;
#[doc = "< add amount of src inverse to itself,  */"]
pub const L_BLEND_GRAY_WITH_INVERSE: ::std::os::raw::c_uint = 5;
#[doc = " Blend Types"]
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
#[doc = "< colorize non-black pixels"]
pub const L_PAINT_LIGHT: ::std::os::raw::c_uint = 1;
#[doc = "< colorize non-white pixels"]
pub const L_PAINT_DARK: ::std::os::raw::c_uint = 2;
#[doc = " Paint Selection"]
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
#[doc = "< set all bits in each pixel to 1"]
pub const L_SET_PIXELS: ::std::os::raw::c_uint = 1;
#[doc = "< set all bits in each pixel to 0"]
pub const L_CLEAR_PIXELS: ::std::os::raw::c_uint = 2;
#[doc = "< flip all bits in each pixel"]
pub const L_FLIP_PIXELS: ::std::os::raw::c_uint = 3;
#[doc = " Pixel Setting"]
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
#[doc = "< save if value is less than threshold"]
pub const L_SELECT_IF_LT: ::std::os::raw::c_uint = 1;
#[doc = "< save if value is more than threshold"]
pub const L_SELECT_IF_GT: ::std::os::raw::c_uint = 2;
#[doc = "< save if value is <= to the threshold"]
pub const L_SELECT_IF_LTE: ::std::os::raw::c_uint = 3;
#[doc = "< save if value is >= to the threshold"]
pub const L_SELECT_IF_GTE: ::std::os::raw::c_uint = 4;
#[doc = " Size Comparison"]
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
#[doc = "< select by width; 1 bpp"]
pub const L_SELECT_BY_WIDTH: ::std::os::raw::c_uint = 1;
#[doc = "< select by height; 1 bpp"]
pub const L_SELECT_BY_HEIGHT: ::std::os::raw::c_uint = 2;
#[doc = "< select by max of width and        */"]
pub const L_SELECT_BY_MAX_DIMENSION: ::std::os::raw::c_uint = 3;
#[doc = "< select by foreground area; 1 bpp"]
pub const L_SELECT_BY_AREA: ::std::os::raw::c_uint = 4;
#[doc = "< select by perimeter; 1 bpp"]
pub const L_SELECT_BY_PERIMETER: ::std::os::raw::c_uint = 5;
#[doc = " Size Selection"]
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
#[doc = "< width must satisfy constraint"]
pub const L_SELECT_WIDTH: ::std::os::raw::c_uint = 1;
#[doc = "< height must satisfy constraint"]
pub const L_SELECT_HEIGHT: ::std::os::raw::c_uint = 2;
#[doc = "< x value must satisfy constraint"]
pub const L_SELECT_XVAL: ::std::os::raw::c_uint = 3;
#[doc = "< y value must satisfy constraint"]
pub const L_SELECT_YVAL: ::std::os::raw::c_uint = 4;
#[doc = "< either width or height (or xval       */"]
pub const L_SELECT_IF_EITHER: ::std::os::raw::c_uint = 5;
#[doc = "< both width and height (or xval        */"]
pub const L_SELECT_IF_BOTH: ::std::os::raw::c_uint = 6;
#[doc = " Location Filter"]
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
#[doc = "< check and possibly modify width"]
pub const L_CHECK_WIDTH: ::std::os::raw::c_uint = 1;
#[doc = "< check and possibly modify height"]
pub const L_CHECK_HEIGHT: ::std::os::raw::c_uint = 2;
#[doc = "< check and possibly modify both"]
pub const L_CHECK_BOTH: ::std::os::raw::c_uint = 3;
#[doc = " Boxa Check"]
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
#[doc = "< use red component"]
pub const L_SELECT_RED: ::std::os::raw::c_uint = 1;
#[doc = "< use green component"]
pub const L_SELECT_GREEN: ::std::os::raw::c_uint = 2;
#[doc = "< use blue component"]
pub const L_SELECT_BLUE: ::std::os::raw::c_uint = 3;
#[doc = "< use min color component"]
pub const L_SELECT_MIN: ::std::os::raw::c_uint = 4;
#[doc = "< use max color component"]
pub const L_SELECT_MAX: ::std::os::raw::c_uint = 5;
#[doc = "< use average of color components"]
pub const L_SELECT_AVERAGE: ::std::os::raw::c_uint = 6;
#[doc = "< use hue value (in HSV color space)"]
pub const L_SELECT_HUE: ::std::os::raw::c_uint = 7;
#[doc = "< use saturation value (in HSV space)"]
pub const L_SELECT_SATURATION: ::std::os::raw::c_uint = 8;
#[doc = "< use weighted average of color comps"]
pub const L_SELECT_WEIGHTED: ::std::os::raw::c_uint = 9;
#[doc = " Color Selection"]
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
#[doc = "< intermediate of diff component values"]
pub const L_INTERMED_DIFF: ::std::os::raw::c_uint = 1;
#[doc = "< diff average closest comps to third"]
pub const L_AVE_MAX_DIFF_2: ::std::os::raw::c_uint = 2;
#[doc = "< maximum diff of component values"]
pub const L_MAX_DIFF: ::std::os::raw::c_uint = 3;
#[doc = " Color Content"]
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
#[doc = "< use LSB"]
pub const L_LS_BYTE: ::std::os::raw::c_uint = 1;
#[doc = "< use MSB"]
pub const L_MS_BYTE: ::std::os::raw::c_uint = 2;
#[doc = "< use LSB if max(val) < 256; else MSB"]
pub const L_AUTO_BYTE: ::std::os::raw::c_uint = 3;
#[doc = "< use max(val, 255)"]
pub const L_CLIP_TO_FF: ::std::os::raw::c_uint = 4;
#[doc = "< use two LSB"]
pub const L_LS_TWO_BYTES: ::std::os::raw::c_uint = 5;
#[doc = "< use two MSB"]
pub const L_MS_TWO_BYTES: ::std::os::raw::c_uint = 6;
#[doc = "< use max(val, 65535)"]
pub const L_CLIP_TO_FFFF: ::std::os::raw::c_uint = 7;
#[doc = " 16-bit Conversion"]
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
#[doc = "< use area map rotation, if possible"]
pub const L_ROTATE_AREA_MAP: ::std::os::raw::c_uint = 1;
#[doc = "< use shear rotation"]
pub const L_ROTATE_SHEAR: ::std::os::raw::c_uint = 2;
#[doc = "< use sampling"]
pub const L_ROTATE_SAMPLING: ::std::os::raw::c_uint = 3;
#[doc = " Rotation Type"]
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
#[doc = "< bring in white pixels from the outside"]
pub const L_BRING_IN_WHITE: ::std::os::raw::c_uint = 1;
#[doc = "< bring in black pixels from the outside"]
pub const L_BRING_IN_BLACK: ::std::os::raw::c_uint = 2;
#[doc = " Background Color"]
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
#[doc = "< shear image about UL corner"]
pub const L_SHEAR_ABOUT_CORNER: ::std::os::raw::c_uint = 1;
#[doc = "< shear image about center"]
pub const L_SHEAR_ABOUT_CENTER: ::std::os::raw::c_uint = 2;
#[doc = " Shear Point"]
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
#[doc = "< translate, scale, rotate"]
pub const L_TR_SC_RO: ::std::os::raw::c_uint = 1;
#[doc = "< scale, rotate, translate"]
pub const L_SC_RO_TR: ::std::os::raw::c_uint = 2;
#[doc = "< rotate, translate, scale"]
pub const L_RO_TR_SC: ::std::os::raw::c_uint = 3;
#[doc = "< translate, rotate, scale"]
pub const L_TR_RO_SC: ::std::os::raw::c_uint = 4;
#[doc = "< rotate, scale, translate"]
pub const L_RO_SC_TR: ::std::os::raw::c_uint = 5;
#[doc = "< scale, translate, rotate"]
pub const L_SC_TR_RO: ::std::os::raw::c_uint = 6;
#[doc = " Affine Transform Order"]
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
#[doc = "< fill white pixels (e.g, in fg map)"]
pub const L_FILL_WHITE: ::std::os::raw::c_uint = 1;
#[doc = "< fill black pixels (e.g., in bg map)"]
pub const L_FILL_BLACK: ::std::os::raw::c_uint = 2;
#[doc = " Grayscale Fill"]
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
#[doc = "< set pixels to white"]
pub const L_SET_WHITE: ::std::os::raw::c_uint = 1;
#[doc = "< set pixels to black"]
pub const L_SET_BLACK: ::std::os::raw::c_uint = 2;
#[doc = " BlackWhite Set"]
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
#[doc = "< get white pixel value"]
pub const L_GET_WHITE_VAL: ::std::os::raw::c_uint = 1;
#[doc = "< get black pixel value"]
pub const L_GET_BLACK_VAL: ::std::os::raw::c_uint = 2;
#[doc = " BlackWhite Get"]
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
#[doc = "< white pixels are 0xff or 0xffff; black are 0"]
pub const L_WHITE_IS_MAX: ::std::os::raw::c_uint = 1;
#[doc = "< black pixels are 0xff or 0xffff; white are 0"]
pub const L_BLACK_IS_MAX: ::std::os::raw::c_uint = 2;
#[doc = " BlackWhite Sum"]
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
#[doc = "< dist to black with no prop; 1 bpp"]
pub const DEFAULT_CLIP_LOWER_1: ::std::os::raw::c_uint = 10;
#[doc = "< dist to black with no prop; 1 bpp"]
pub const DEFAULT_CLIP_UPPER_1: ::std::os::raw::c_uint = 10;
#[doc = "< dist to black with no prop; 2 bpp"]
pub const DEFAULT_CLIP_LOWER_2: ::std::os::raw::c_uint = 5;
#[doc = "< dist to black with no prop; 2 bpp"]
pub const DEFAULT_CLIP_UPPER_2: ::std::os::raw::c_uint = 5;
#[doc = " Dither Distance"]
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
#[doc = "< L1 distance (e.g., in color space)"]
pub const L_MANHATTAN_DISTANCE: ::std::os::raw::c_uint = 1;
#[doc = "< L2 distance"]
pub const L_EUCLIDEAN_DISTANCE: ::std::os::raw::c_uint = 2;
#[doc = " Distance Type"]
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
#[doc = "< values < 0"]
pub const L_NEGATIVE: ::std::os::raw::c_uint = 1;
#[doc = "< values >= 0"]
pub const L_NON_NEGATIVE: ::std::os::raw::c_uint = 2;
#[doc = "< values > 0"]
pub const L_POSITIVE: ::std::os::raw::c_uint = 3;
#[doc = "< values <= 0"]
pub const L_NON_POSITIVE: ::std::os::raw::c_uint = 4;
#[doc = "< values = 0"]
pub const L_ZERO: ::std::os::raw::c_uint = 5;
#[doc = "< all values"]
pub const L_ALL: ::std::os::raw::c_uint = 6;
#[doc = " Distance Value"]
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
#[doc = "< average of abs values"]
pub const L_MEAN_ABSVAL: ::std::os::raw::c_uint = 1;
#[doc = "< median value of set"]
pub const L_MEDIAN_VAL: ::std::os::raw::c_uint = 2;
#[doc = "< mode value of set"]
pub const L_MODE_VAL: ::std::os::raw::c_uint = 3;
#[doc = "< mode count of set"]
pub const L_MODE_COUNT: ::std::os::raw::c_uint = 4;
#[doc = "< rms of values"]
pub const L_ROOT_MEAN_SQUARE: ::std::os::raw::c_uint = 5;
#[doc = "< standard deviation from mean"]
pub const L_STANDARD_DEVIATION: ::std::os::raw::c_uint = 6;
#[doc = "< variance of values"]
pub const L_VARIANCE: ::std::os::raw::c_uint = 7;
#[doc = " Stats Type"]
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
#[doc = "< select 'n' consecutive"]
pub const L_CHOOSE_CONSECUTIVE: ::std::os::raw::c_uint = 1;
#[doc = "< select at intervals of 'n'"]
pub const L_CHOOSE_SKIP_BY: ::std::os::raw::c_uint = 2;
#[doc = " Index Selection"]
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
#[doc = "< low confidence on text orientation"]
pub const L_TEXT_ORIENT_UNKNOWN: ::std::os::raw::c_uint = 0;
#[doc = "< portrait, text rightside-up"]
pub const L_TEXT_ORIENT_UP: ::std::os::raw::c_uint = 1;
#[doc = "< landscape, text up to left"]
pub const L_TEXT_ORIENT_LEFT: ::std::os::raw::c_uint = 2;
#[doc = "< portrait, text upside-down"]
pub const L_TEXT_ORIENT_DOWN: ::std::os::raw::c_uint = 3;
#[doc = "< landscape, text up to right"]
pub const L_TEXT_ORIENT_RIGHT: ::std::os::raw::c_uint = 4;
#[doc = " Text Orientation"]
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
#[doc = "< filters for horizontal edges"]
pub const L_HORIZONTAL_EDGES: ::std::os::raw::c_uint = 0;
#[doc = "< filters for vertical edges"]
pub const L_VERTICAL_EDGES: ::std::os::raw::c_uint = 1;
#[doc = "< filters for all edges"]
pub const L_ALL_EDGES: ::std::os::raw::c_uint = 2;
#[doc = " Edge Orientation"]
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
#[doc = "< horizontal line"]
pub const L_HORIZONTAL_LINE: ::std::os::raw::c_uint = 0;
#[doc = "< 45 degree line with positive slope"]
pub const L_POS_SLOPE_LINE: ::std::os::raw::c_uint = 1;
#[doc = "< vertical line"]
pub const L_VERTICAL_LINE: ::std::os::raw::c_uint = 2;
#[doc = "< 45 degree line with negative slope"]
pub const L_NEG_SLOPE_LINE: ::std::os::raw::c_uint = 3;
#[doc = "< neither horizontal nor vertical"]
pub const L_OBLIQUE_LINE: ::std::os::raw::c_uint = 4;
#[doc = " Line Orientation"]
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
#[doc = "< typical: page is viewed with height > width"]
pub const L_PORTRAIT_MODE: ::std::os::raw::c_uint = 0;
#[doc = "< page is viewed at 90 deg to portrait mode"]
pub const L_LANDSCAPE_MODE: ::std::os::raw::c_uint = 1;
#[doc = " Image Orientation"]
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
#[doc = "< scan from left"]
pub const L_FROM_LEFT: ::std::os::raw::c_uint = 0;
#[doc = "< scan from right"]
pub const L_FROM_RIGHT: ::std::os::raw::c_uint = 1;
#[doc = "< scan from top"]
pub const L_FROM_TOP: ::std::os::raw::c_uint = 2;
#[doc = "< scan from bottom"]
pub const L_FROM_BOT: ::std::os::raw::c_uint = 3;
#[doc = "< scan in negative direction"]
pub const L_SCAN_NEGATIVE: ::std::os::raw::c_uint = 4;
#[doc = "< scan in positive direction"]
pub const L_SCAN_POSITIVE: ::std::os::raw::c_uint = 5;
#[doc = "< scan in both directions"]
pub const L_SCAN_BOTH: ::std::os::raw::c_uint = 6;
#[doc = "< horizontal scan (direction unimportant)"]
pub const L_SCAN_HORIZONTAL: ::std::os::raw::c_uint = 7;
#[doc = "< vertical scan (direction unimportant)"]
pub const L_SCAN_VERTICAL: ::std::os::raw::c_uint = 8;
#[doc = " Scan Direction"]
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
#[doc = "< do not adjust"]
pub const L_ADJUST_SKIP: ::std::os::raw::c_uint = 0;
#[doc = "< adjust left edge"]
pub const L_ADJUST_LEFT: ::std::os::raw::c_uint = 1;
#[doc = "< adjust right edge"]
pub const L_ADJUST_RIGHT: ::std::os::raw::c_uint = 2;
#[doc = "< adjust both left and right edges"]
pub const L_ADJUST_LEFT_AND_RIGHT: ::std::os::raw::c_uint = 3;
#[doc = "< adjust top edge"]
pub const L_ADJUST_TOP: ::std::os::raw::c_uint = 4;
#[doc = "< adjust bottom edge"]
pub const L_ADJUST_BOT: ::std::os::raw::c_uint = 5;
#[doc = "< adjust both top and bottom edges"]
pub const L_ADJUST_TOP_AND_BOT: ::std::os::raw::c_uint = 6;
#[doc = "< choose the min median value"]
pub const L_ADJUST_CHOOSE_MIN: ::std::os::raw::c_uint = 7;
#[doc = "< choose the max median value"]
pub const L_ADJUST_CHOOSE_MAX: ::std::os::raw::c_uint = 8;
#[doc = "< set left side to a given value"]
pub const L_SET_LEFT: ::std::os::raw::c_uint = 9;
#[doc = "< set right side to a given value"]
pub const L_SET_RIGHT: ::std::os::raw::c_uint = 10;
#[doc = "< set top side to a given value"]
pub const L_SET_TOP: ::std::os::raw::c_uint = 11;
#[doc = "< set bottom side to a given value"]
pub const L_SET_BOT: ::std::os::raw::c_uint = 12;
#[doc = "< get left side location"]
pub const L_GET_LEFT: ::std::os::raw::c_uint = 13;
#[doc = "< get right side location"]
pub const L_GET_RIGHT: ::std::os::raw::c_uint = 14;
#[doc = "< get top side location"]
pub const L_GET_TOP: ::std::os::raw::c_uint = 15;
#[doc = "< get bottom side location"]
pub const L_GET_BOT: ::std::os::raw::c_uint = 16;
#[doc = " Box Adjustment"]
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
#[doc = "< use boundaries giving min size"]
pub const L_USE_MINSIZE: ::std::os::raw::c_uint = 1;
#[doc = "< use boundaries giving max size"]
pub const L_USE_MAXSIZE: ::std::os::raw::c_uint = 2;
#[doc = "< modify boundary if big location diff"]
pub const L_SUB_ON_LOC_DIFF: ::std::os::raw::c_uint = 3;
#[doc = "< modify boundary if big size diff"]
pub const L_SUB_ON_SIZE_DIFF: ::std::os::raw::c_uint = 4;
#[doc = "< modify boundary with capped min"]
pub const L_USE_CAPPED_MIN: ::std::os::raw::c_uint = 5;
#[doc = "< modify boundary with capped max"]
pub const L_USE_CAPPED_MAX: ::std::os::raw::c_uint = 6;
#[doc = " Box Boundary Mod"]
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
#[doc = "< resize to bounding region; remove smaller"]
pub const L_COMBINE: ::std::os::raw::c_uint = 1;
#[doc = "< only remove smaller"]
pub const L_REMOVE_SMALL: ::std::os::raw::c_uint = 2;
#[doc = " Box Overlap Mod"]
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
#[doc = "< use union of two boxes"]
pub const L_GEOMETRIC_UNION: ::std::os::raw::c_uint = 1;
#[doc = "< use intersection of two boxes"]
pub const L_GEOMETRIC_INTERSECTION: ::std::os::raw::c_uint = 2;
#[doc = "< use box with largest area"]
pub const L_LARGEST_AREA: ::std::os::raw::c_uint = 3;
#[doc = "< use box with smallest area"]
pub const L_SMALLEST_AREA: ::std::os::raw::c_uint = 4;
#[doc = " Box Combine or Select"]
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
#[doc = "< consider all boxes in the sequence"]
pub const L_USE_ALL_BOXES: ::std::os::raw::c_uint = 1;
#[doc = "< consider boxes with the same parity"]
pub const L_USE_SAME_PARITY_BOXES: ::std::os::raw::c_uint = 2;
#[doc = " Box Replacement"]
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
#[doc = "< UL corner"]
pub const L_UPPER_LEFT: ::std::os::raw::c_uint = 1;
#[doc = "< UR corner"]
pub const L_UPPER_RIGHT: ::std::os::raw::c_uint = 2;
#[doc = "< LL corner"]
pub const L_LOWER_LEFT: ::std::os::raw::c_uint = 3;
#[doc = "< LR corner"]
pub const L_LOWER_RIGHT: ::std::os::raw::c_uint = 4;
#[doc = "< center"]
pub const L_BOX_CENTER: ::std::os::raw::c_uint = 5;
#[doc = " Box Corners and Center"]
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
#[doc = "< increasing stretch or contraction to left"]
pub const L_WARP_TO_LEFT: ::std::os::raw::c_uint = 1;
#[doc = "< increasing stretch or contraction to right"]
pub const L_WARP_TO_RIGHT: ::std::os::raw::c_uint = 2;
#[doc = " Horiz Warp Stretch"]
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
#[doc = "< stretch or contraction grows linearly"]
pub const L_LINEAR_WARP: ::std::os::raw::c_uint = 1;
#[doc = "< stretch or contraction grows quadratically"]
pub const L_QUADRATIC_WARP: ::std::os::raw::c_uint = 2;
#[doc = " Horiz Warp Mode"]
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
#[doc = "< linear interpolation from src pixels"]
pub const L_INTERPOLATED: ::std::os::raw::c_uint = 1;
#[doc = "< nearest src pixel sampling only"]
pub const L_SAMPLED: ::std::os::raw::c_uint = 2;
#[doc = " Pixel Selection"]
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
#[doc = "< thin foreground of 1 bpp image"]
pub const L_THIN_FG: ::std::os::raw::c_uint = 1;
#[doc = "< thin background of 1 bpp image"]
pub const L_THIN_BG: ::std::os::raw::c_uint = 2;
#[doc = " Thinning Polarity"]
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
#[doc = "< determine runlengths of horizontal runs"]
pub const L_HORIZONTAL_RUNS: ::std::os::raw::c_uint = 0;
#[doc = "< determine runlengths of vertical runs"]
pub const L_VERTICAL_RUNS: ::std::os::raw::c_uint = 1;
#[doc = " Runlength Direction"]
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
#[doc = "< Sobel edge filter"]
pub const L_SOBEL_EDGE: ::std::os::raw::c_uint = 1;
#[doc = "< Two-sided edge filter"]
pub const L_TWO_SIDED_EDGE: ::std::os::raw::c_uint = 2;
#[doc = " Edge Filter"]
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
#[doc = "< sensor order left-to-right RGB"]
pub const L_SUBPIXEL_ORDER_RGB: ::std::os::raw::c_uint = 1;
#[doc = "< sensor order left-to-right BGR"]
pub const L_SUBPIXEL_ORDER_BGR: ::std::os::raw::c_uint = 2;
#[doc = "< sensor order top-to-bottom RGB"]
pub const L_SUBPIXEL_ORDER_VRGB: ::std::os::raw::c_uint = 3;
#[doc = "< sensor order top-to-bottom BGR"]
pub const L_SUBPIXEL_ORDER_VBGR: ::std::os::raw::c_uint = 4;
#[doc = " Subpixel Color Order"]
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
#[doc = "< Use hue-saturation histogram"]
pub const L_HS_HISTO: ::std::os::raw::c_uint = 1;
#[doc = "< Use hue-value histogram"]
pub const L_HV_HISTO: ::std::os::raw::c_uint = 2;
#[doc = "< Use saturation-value histogram"]
pub const L_SV_HISTO: ::std::os::raw::c_uint = 3;
#[doc = " HSV Histogram"]
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
#[doc = "< Use pixels with specified HSV region"]
pub const L_INCLUDE_REGION: ::std::os::raw::c_uint = 1;
#[doc = "< Use pixels outside HSV region"]
pub const L_EXCLUDE_REGION: ::std::os::raw::c_uint = 2;
#[doc = " HSV Region"]
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
#[doc = "< Add text above the image"]
pub const L_ADD_ABOVE: ::std::os::raw::c_uint = 1;
#[doc = "< Add text below the image"]
pub const L_ADD_BELOW: ::std::os::raw::c_uint = 2;
#[doc = "< Add text to the left of the image"]
pub const L_ADD_LEFT: ::std::os::raw::c_uint = 3;
#[doc = "< Add text to the right of the image"]
pub const L_ADD_RIGHT: ::std::os::raw::c_uint = 4;
#[doc = "< Add text over the top of the image"]
pub const L_ADD_AT_TOP: ::std::os::raw::c_uint = 5;
#[doc = "< Add text over the bottom of the image"]
pub const L_ADD_AT_BOT: ::std::os::raw::c_uint = 6;
#[doc = "< Add text over left side of the image"]
pub const L_ADD_AT_LEFT: ::std::os::raw::c_uint = 7;
#[doc = "< Add text over right side of the image"]
pub const L_ADD_AT_RIGHT: ::std::os::raw::c_uint = 8;
#[doc = " Add Text Location"]
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
#[doc = "< Plot horizontally at top"]
pub const L_PLOT_AT_TOP: ::std::os::raw::c_uint = 1;
#[doc = "< Plot horizontally at middle"]
pub const L_PLOT_AT_MID_HORIZ: ::std::os::raw::c_uint = 2;
#[doc = "< Plot horizontally at bottom"]
pub const L_PLOT_AT_BOT: ::std::os::raw::c_uint = 3;
#[doc = "< Plot vertically at left"]
pub const L_PLOT_AT_LEFT: ::std::os::raw::c_uint = 4;
#[doc = "< Plot vertically at middle"]
pub const L_PLOT_AT_MID_VERT: ::std::os::raw::c_uint = 5;
#[doc = "< Plot vertically at right"]
pub const L_PLOT_AT_RIGHT: ::std::os::raw::c_uint = 6;
#[doc = " Pix Plot"]
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
#[doc = "< Select the interior part"]
pub const L_USE_INNER: ::std::os::raw::c_uint = 1;
#[doc = "< Select the outer part (e.g., a frame)"]
pub const L_USE_OUTER: ::std::os::raw::c_uint = 2;
#[doc = " Mask Generation"]
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
#[doc = "< Use xzgv with pixDisplay()"]
pub const L_DISPLAY_WITH_XZGV: ::std::os::raw::c_uint = 1;
#[doc = "< Use xli with pixDisplay()"]
pub const L_DISPLAY_WITH_XLI: ::std::os::raw::c_uint = 2;
#[doc = "< Use xv with pixDisplay()"]
pub const L_DISPLAY_WITH_XV: ::std::os::raw::c_uint = 3;
#[doc = "< Use irfvanview (win) with pixDisplay()"]
pub const L_DISPLAY_WITH_IV: ::std::os::raw::c_uint = 4;
#[doc = "< Use open (apple) with pixDisplay()"]
pub const L_DISPLAY_WITH_OPEN: ::std::os::raw::c_uint = 5;
#[doc = " Display Program"]
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
#[doc = "< Write full resolution chroma"]
pub const L_NO_CHROMA_SAMPLING_JPEG: ::std::os::raw::c_uint = 1;
#[doc = " Flags used in Pix::special"]
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
#[doc = "< Clip negative values to 0"]
pub const L_CLIP_TO_ZERO: ::std::os::raw::c_uint = 1;
#[doc = "< Convert to positive using L_ABS()"]
pub const L_TAKE_ABSVAL: ::std::os::raw::c_uint = 2;
#[doc = " Negative Value"]
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
#[doc = "< Choose values less than zero"]
pub const L_LESS_THAN_ZERO: ::std::os::raw::c_uint = 1;
#[doc = "< Choose values equal to zero"]
pub const L_EQUAL_TO_ZERO: ::std::os::raw::c_uint = 2;
#[doc = "< Choose values greater than zero"]
pub const L_GREATER_THAN_ZERO: ::std::os::raw::c_uint = 3;
#[doc = " Relative To Zero"]
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
#[doc = "< Add trailing slash to string"]
pub const L_ADD_TRAIL_SLASH: ::std::os::raw::c_uint = 1;
#[doc = "< Remove trailing slash from string"]
pub const L_REMOVE_TRAIL_SLASH: ::std::os::raw::c_uint = 2;
#[doc = " Trailing Slash"]
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
#[doc = " Allocator function type"]
pub type alloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>;
#[doc = " Deallocator function type"]
pub type dealloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Recog {
    #[doc = "< scale all examples to this width;      */"]
    pub scalew: l_int32,
    #[doc = "< scale all examples to this height;     */"]
    pub scaleh: l_int32,
    #[doc = "< use a value > 0 to convert the bitmap  */"]
    pub linew: l_int32,
    #[doc = "< template use: use either the average   */"]
    pub templ_use: l_int32,
    #[doc = "< initialize container arrays to this"]
    pub maxarraysize: l_int32,
    #[doc = "< size of character set"]
    pub setsize: l_int32,
    #[doc = "< for binarizing if depth > 1"]
    pub threshold: l_int32,
    #[doc = "< vertical jiggle on nominal centroid    */"]
    pub maxyshift: l_int32,
    #[doc = "< one of L_ARABIC_NUMERALS, etc."]
    pub charset_type: l_int32,
    #[doc = "< expected number of classes in charset"]
    pub charset_size: l_int32,
    #[doc = "< min number of samples without padding"]
    pub min_nopad: l_int32,
    #[doc = "< number of training samples"]
    pub num_samples: l_int32,
    #[doc = "< min width averaged unscaled templates"]
    pub minwidth_u: l_int32,
    #[doc = "< max width averaged unscaled templates"]
    pub maxwidth_u: l_int32,
    #[doc = "< min height averaged unscaled templates"]
    pub minheight_u: l_int32,
    #[doc = "< max height averaged unscaled templates"]
    pub maxheight_u: l_int32,
    #[doc = "< min width averaged scaled templates"]
    pub minwidth: l_int32,
    #[doc = "< max width averaged scaled templates"]
    pub maxwidth: l_int32,
    #[doc = "< set to 1 when averaged bitmaps are made"]
    pub ave_done: l_int32,
    #[doc = "< set to 1 when training is complete or  */"]
    pub train_done: l_int32,
    #[doc = "< max width/height ratio to split"]
    pub max_wh_ratio: l_float32,
    #[doc = "< max of max/min template height ratio"]
    pub max_ht_ratio: l_float32,
    #[doc = "< min component width kept in splitting"]
    pub min_splitw: l_int32,
    #[doc = "< max component height kept in splitting"]
    pub max_splith: l_int32,
    #[doc = "< text array for arbitrary char set"]
    pub sa_text: *mut Sarray,
    #[doc = "< index-to-char lut for arbitrary charset"]
    pub dna_tochar: *mut L_Dna,
    #[doc = "< table for finding centroids"]
    pub centtab: *mut l_int32,
    #[doc = "< table for finding pixel sums"]
    pub sumtab: *mut l_int32,
    #[doc = "< all unscaled templates for each class"]
    pub pixaa_u: *mut Pixaa,
    #[doc = "< centroids of all unscaled templates"]
    pub ptaa_u: *mut Ptaa,
    #[doc = "< area of all unscaled templates"]
    pub naasum_u: *mut Numaa,
    #[doc = "< all (scaled) templates for each class"]
    pub pixaa: *mut Pixaa,
    #[doc = "< centroids of all (scaledl) templates"]
    pub ptaa: *mut Ptaa,
    #[doc = "< area of all (scaled) templates"]
    pub naasum: *mut Numaa,
    #[doc = "< averaged unscaled templates per class"]
    pub pixa_u: *mut Pixa,
    #[doc = "< centroids of unscaled ave. templates"]
    pub pta_u: *mut Pta,
    #[doc = "< area of unscaled averaged templates"]
    pub nasum_u: *mut Numa,
    #[doc = "< averaged (scaled) templates per class"]
    pub pixa: *mut Pixa,
    #[doc = "< centroids of (scaled) ave. templates"]
    pub pta: *mut Pta,
    #[doc = "< area of (scaled) averaged templates"]
    pub nasum: *mut Numa,
    #[doc = "< all input training images"]
    pub pixa_tr: *mut Pixa,
    #[doc = "< unscaled and scaled averaged bitmaps"]
    pub pixadb_ave: *mut Pixa,
    #[doc = "< input images for identifying"]
    pub pixa_id: *mut Pixa,
    #[doc = "< debug: best match of input against ave."]
    pub pixdb_ave: *mut Pix,
    #[doc = "< debug: best matches within range"]
    pub pixdb_range: *mut Pix,
    #[doc = "< debug: bootstrap training results"]
    pub pixadb_boot: *mut Pixa,
    #[doc = "< debug: splitting results"]
    pub pixadb_split: *mut Pixa,
    #[doc = "< bmf fonts"]
    pub bmf: *mut L_Bmf,
    #[doc = "< font size of bmf; default is 6 pt"]
    pub bmf_size: l_int32,
    #[doc = "< temp data used for image decoding"]
    pub did: *mut L_Rdid,
    #[doc = "< temp data used for holding best char"]
    pub rch: *mut L_Rch,
    #[doc = "< temp data used for array of best chars"]
    pub rcha: *mut L_Rcha,
}
#[test]
fn bindgen_test_layout_L_Recog() {
    assert_eq!(
        ::std::mem::size_of::<L_Recog>(),
        320usize,
        concat!("Size of: ", stringify!(L_Recog))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Recog>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Recog))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).scalew as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scalew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).scaleh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scaleh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).linew as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(linew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).templ_use as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(templ_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxarraysize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxarraysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).setsize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(setsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).threshold as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxyshift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxyshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).charset_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).charset_size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).min_nopad as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_nopad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).num_samples as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(num_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minwidth_u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxwidth_u as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minheight_u as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minheight_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxheight_u as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxheight_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minwidth as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxwidth as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ave_done as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ave_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).train_done as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(train_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_wh_ratio as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_wh_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_ht_ratio as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_ht_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).min_splitw as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_splitw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_splith as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_splith)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).sa_text as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sa_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).dna_tochar as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(dna_tochar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).centtab as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(centtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).sumtab as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sumtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixaa_u as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ptaa_u as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).naasum_u as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixaa as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ptaa as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).naasum as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pta_u as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).nasum_u as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pta as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).nasum as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_tr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_tr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_ave as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_ave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_id as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixdb_ave as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_ave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixdb_range as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_boot as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_split as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).bmf as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).bmf_size as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).did as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).rch as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).rcha as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rcha)
        )
    );
}
pub type L_RECOG = L_Recog;
#[doc = "  Data returned from correlation matching on a single character"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rch {
    #[doc = "< index of best template"]
    pub index: l_int32,
    #[doc = "< correlation score of best template"]
    pub score: l_float32,
    #[doc = "< character string of best template"]
    pub text: *mut ::std::os::raw::c_char,
    #[doc = "< index of best sample (within the best    */"]
    pub sample: l_int32,
    #[doc = "< x-location of template (delx + shiftx)"]
    pub xloc: l_int32,
    #[doc = "< y-location of template (dely + shifty)"]
    pub yloc: l_int32,
    #[doc = "< width of best template"]
    pub width: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rch() {
    assert_eq!(
        ::std::mem::size_of::<L_Rch>(),
        32usize,
        concat!("Size of: ", stringify!(L_Rch))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rch>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).score as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).sample as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).xloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(xloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).yloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(yloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(width)
        )
    );
}
pub type L_RCH = L_Rch;
#[doc = "  Data returned from correlation matching on an array of characters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rcha {
    #[doc = "< indices of best templates"]
    pub naindex: *mut Numa,
    #[doc = "< correlation scores of best templates"]
    pub nascore: *mut Numa,
    #[doc = "< character strings of best templates"]
    pub satext: *mut Sarray,
    #[doc = "< indices of best samples"]
    pub nasample: *mut Numa,
    #[doc = "< x-locations of templates (delx + shiftx)"]
    pub naxloc: *mut Numa,
    #[doc = "< y-locations of templates (dely + shifty)"]
    pub nayloc: *mut Numa,
    #[doc = "< widths of best templates"]
    pub nawidth: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rcha() {
    assert_eq!(
        ::std::mem::size_of::<L_Rcha>(),
        56usize,
        concat!("Size of: ", stringify!(L_Rcha))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rcha>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rcha))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).naindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nascore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).satext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(satext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nasample as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nasample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).naxloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nayloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nayloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nawidth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nawidth)
        )
    );
}
pub type L_RCHA = L_Rcha;
#[doc = "  Data used for decoding a line of characters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rdid {
    #[doc = "< clone of pix to be decoded"]
    pub pixs: *mut Pix,
    #[doc = "< count array for each averaged template"]
    pub counta: *mut *mut l_int32,
    #[doc = "< best y-shift array per average template"]
    pub delya: *mut *mut l_int32,
    #[doc = "< number of averaged templates"]
    pub narray: l_int32,
    #[doc = "< size of count array (width of pixs)"]
    pub size: l_int32,
    #[doc = "< setwidths for each template"]
    pub setwidth: *mut l_int32,
    #[doc = "< pixel count in pixs by column"]
    pub nasum: *mut Numa,
    #[doc = "< first moment of pixels in pixs by cols"]
    pub namoment: *mut Numa,
    #[doc = "< 1 if full arrays are made; 0 otherwise"]
    pub fullarrays: l_int32,
    #[doc = "< channel coeffs for template fg term"]
    pub beta: *mut l_float32,
    #[doc = "< channel coeffs for bit-and term"]
    pub gamma: *mut l_float32,
    #[doc = "< score on trellis"]
    pub trellisscore: *mut l_float32,
    #[doc = "< template on trellis (for backtrack)"]
    pub trellistempl: *mut l_int32,
    #[doc = "< indices of best path templates"]
    pub natempl: *mut Numa,
    #[doc = "< x locations of best path templates"]
    pub naxloc: *mut Numa,
    #[doc = "< y locations of best path templates"]
    pub nadely: *mut Numa,
    #[doc = "< widths of best path templates"]
    pub nawidth: *mut Numa,
    #[doc = "< Viterbi result for splitting input pixs"]
    pub boxa: *mut Boxa,
    #[doc = "< correlation scores: best path templates"]
    pub nascore: *mut Numa,
    #[doc = "< indices of best rescored templates"]
    pub natempl_r: *mut Numa,
    #[doc = "< samples of best scored templates"]
    pub nasample_r: *mut Numa,
    #[doc = "< x locations of best rescoredtemplates"]
    pub naxloc_r: *mut Numa,
    #[doc = "< y locations of best rescoredtemplates"]
    pub nadely_r: *mut Numa,
    #[doc = "< widths of best rescoredtemplates"]
    pub nawidth_r: *mut Numa,
    #[doc = "< correlation scores: rescored templates"]
    pub nascore_r: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rdid() {
    assert_eq!(
        ::std::mem::size_of::<L_Rdid>(),
        192usize,
        concat!("Size of: ", stringify!(L_Rdid))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rdid>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rdid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).counta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(counta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).delya as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(delya)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).narray as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(narray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).setwidth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(setwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nasum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).namoment as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(namoment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).fullarrays as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(fullarrays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).beta as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).gamma as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).trellisscore as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellisscore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).trellistempl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellistempl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).natempl as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).naxloc as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nadely as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nawidth as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).boxa as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nascore as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).natempl_r as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nasample_r as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasample_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).naxloc_r as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nadely_r as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nawidth_r as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nascore_r as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore_r)
        )
    );
}
pub type L_RDID = L_Rdid;
#[doc = "< character set type is not specified"]
pub const L_UNKNOWN: ::std::os::raw::c_uint = 0;
#[doc = "< 10 digits"]
pub const L_ARABIC_NUMERALS: ::std::os::raw::c_uint = 1;
#[doc = "< 7 lower-case letters (i,v,x,l,c,d,m)"]
pub const L_LC_ROMAN_NUMERALS: ::std::os::raw::c_uint = 2;
#[doc = "< 7 upper-case letters (I,V,X,L,C,D,M)"]
pub const L_UC_ROMAN_NUMERALS: ::std::os::raw::c_uint = 3;
#[doc = "< 26 lower-case letters"]
pub const L_LC_ALPHA: ::std::os::raw::c_uint = 4;
#[doc = "< 26 upper-case letters"]
pub const L_UC_ALPHA: ::std::os::raw::c_uint = 5;
#[doc = " Character Set"]
pub type _bindgen_ty_92 = ::std::os::raw::c_uint;
#[doc = "< use all templates; default"]
pub const L_USE_ALL_TEMPLATES: ::std::os::raw::c_uint = 0;
#[doc = "< use average templates; special cases"]
pub const L_USE_AVERAGE_TEMPLATES: ::std::os::raw::c_uint = 1;
#[doc = " Template Select"]
pub type _bindgen_ty_93 = ::std::os::raw::c_uint;
#[doc = " Regression test parameter packer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_RegParams {
    #[doc = "< stream to temporary output file for compare mode"]
    pub fp: *mut FILE,
    #[doc = "< name of test, without '_reg'"]
    pub testname: *mut ::std::os::raw::c_char,
    #[doc = "< name of temp file for compare mode output"]
    pub tempfile: *mut ::std::os::raw::c_char,
    #[doc = "< generate, compare or display"]
    pub mode: l_int32,
    #[doc = "< index into saved files for this test; 0-based"]
    pub index: l_int32,
    #[doc = "< overall result of the test"]
    pub success: l_int32,
    #[doc = "< 1 if in display mode; 0 otherwise"]
    pub display: l_int32,
    #[doc = "< marks beginning of the reg test"]
    pub tstart: L_TIMER,
}
#[test]
fn bindgen_test_layout_L_RegParams() {
    assert_eq!(
        ::std::mem::size_of::<L_RegParams>(),
        48usize,
        concat!("Size of: ", stringify!(L_RegParams))
    );
    assert_eq!(
        ::std::mem::align_of::<L_RegParams>(),
        8usize,
        concat!("Alignment of ", stringify!(L_RegParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).testname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(testname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).tempfile as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tempfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).index as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).success as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).display as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).tstart as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tstart)
        )
    );
}
pub type L_REGPARAMS = L_RegParams;
pub const L_REG_GENERATE: ::std::os::raw::c_uint = 0;
pub const L_REG_COMPARE: ::std::os::raw::c_uint = 1;
pub const L_REG_DISPLAY: ::std::os::raw::c_uint = 2;
#[doc = " Running modes for the test */"]
pub type _bindgen_ty_94 = ::std::os::raw::c_uint;
#[doc = " \\file stringcode.h"]
#[doc = ""]
#[doc = "     Data structure to hold accumulating generated code for storing"]
#[doc = "     and extracting serializable leptonica objects (e.g., pixa, recog)."]
#[doc = ""]
#[doc = "     Also a flag for selecting a string from the L_GenAssoc struct"]
#[doc = "     in stringcode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_StrCode {
    #[doc = "< index for function and output file names"]
    pub fileno: l_int32,
    #[doc = "< index into struct currently being stored"]
    pub ifunc: l_int32,
    #[doc = "< store case code for extraction"]
    pub function: *mut SARRAY,
    #[doc = "< store base64 encoded data as strings"]
    pub data: *mut SARRAY,
    #[doc = "< store line in description table"]
    pub descr: *mut SARRAY,
    #[doc = "< number of data strings"]
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_L_StrCode() {
    assert_eq!(
        ::std::mem::size_of::<L_StrCode>(),
        40usize,
        concat!("Size of: ", stringify!(L_StrCode))
    );
    assert_eq!(
        ::std::mem::align_of::<L_StrCode>(),
        8usize,
        concat!("Alignment of ", stringify!(L_StrCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).fileno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).ifunc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(ifunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).descr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(descr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(n)
        )
    );
}
pub type L_STRCODE = L_StrCode;
#[doc = "< typedef for the data type"]
pub const L_STR_TYPE: ::std::os::raw::c_uint = 0;
#[doc = "< name of the data type"]
pub const L_STR_NAME: ::std::os::raw::c_uint = 1;
#[doc = "< reader to get the data type from file"]
pub const L_STR_READER: ::std::os::raw::c_uint = 2;
#[doc = "< reader to get the compressed string in memory"]
pub const L_STR_MEMREADER: ::std::os::raw::c_uint = 3;
#[doc = " Select string in stringcode for a specific serializable data type */"]
pub type _bindgen_ty_95 = ::std::os::raw::c_uint;
#[doc = " \\file sudoku.h"]
#[doc = ""]
#[doc = " <pre>"]
#[doc = "    The L_Sudoku holds all the information of the current state."]
#[doc = ""]
#[doc = "    The input to sudokuCreate() is a file with any number of lines"]
#[doc = "    starting with '#', followed by 9 lines consisting of 9 numbers"]
#[doc = "    in each line.  These have the known values and use 0 for the unknowns."]
#[doc = "    Blank lines are ignored."]
#[doc = ""]
#[doc = "    The %locs array holds the indices of the unknowns, numbered"]
#[doc = "    left-to-right and top-to-bottom from 0 to 80.  The array size"]
#[doc = "    is initialized to %num.  %current is the index into the %locs"]
#[doc = "    array of the current guess: locs[current]."]
#[doc = ""]
#[doc = "    The %state array is used to determine the validity of each guess."]
#[doc = "    It is of size 81, and is initialized by setting the unknowns to 0"]
#[doc = "    and the knowns to their input values."]
#[doc = " </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Sudoku {
    #[doc = "< number of unknowns"]
    pub num: l_int32,
    #[doc = "< location of unknowns"]
    pub locs: *mut l_int32,
    #[doc = "< index into %locs of current location"]
    pub current: l_int32,
    #[doc = "< initial state, with 0 representing     */"]
    pub init: *mut l_int32,
    #[doc = "< present state, including inits and     */"]
    pub state: *mut l_int32,
    #[doc = "< shows current number of guesses"]
    pub nguess: l_int32,
    #[doc = "< set to 1 when solved"]
    pub finished: l_int32,
    #[doc = "< set to 1 if no solution is possible"]
    pub failure: l_int32,
}
#[test]
fn bindgen_test_layout_L_Sudoku() {
    assert_eq!(
        ::std::mem::size_of::<L_Sudoku>(),
        56usize,
        concat!("Size of: ", stringify!(L_Sudoku))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Sudoku>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Sudoku))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).locs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(locs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).current as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).nguess as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(nguess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).finished as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(finished)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).failure as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(failure)
        )
    );
}
pub type L_SUDOKU = L_Sudoku;
pub const L_SUDOKU_INIT: ::std::os::raw::c_uint = 0;
pub const L_SUDOKU_STATE: ::std::os::raw::c_uint = 1;
#[doc = " For printing out array data */"]
pub type _bindgen_ty_96 = ::std::os::raw::c_uint;
#[doc = " Simple data structure to hold watershed data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WShed {
    #[doc = "< clone of input 8 bpp pixs"]
    pub pixs: *mut Pix,
    #[doc = "< clone of input 1 bpp seed (marker) pixm"]
    pub pixm: *mut Pix,
    #[doc = "< minimum depth allowed for a watershed"]
    pub mindepth: l_int32,
    #[doc = "< 16 bpp label pix"]
    pub pixlab: *mut Pix,
    #[doc = "< scratch pix for computing wshed regions"]
    pub pixt: *mut Pix,
    #[doc = "< line ptrs for pixs"]
    pub lines8: *mut *mut ::std::os::raw::c_void,
    #[doc = "< line ptrs for pixm"]
    pub linem1: *mut *mut ::std::os::raw::c_void,
    #[doc = "< line ptrs for pixlab"]
    pub linelab32: *mut *mut ::std::os::raw::c_void,
    #[doc = "< line ptrs for pixt"]
    pub linet1: *mut *mut ::std::os::raw::c_void,
    #[doc = "< result: 1 bpp pixa of watersheds"]
    pub pixad: *mut Pixa,
    #[doc = "< pta of initial seed pixels"]
    pub ptas: *mut Pta,
    #[doc = "< numa of seed indicators; 0 if completed"]
    pub nasi: *mut Numa,
    #[doc = "< numa of initial seed heights"]
    pub nash: *mut Numa,
    #[doc = "< numa of initial minima heights"]
    pub namh: *mut Numa,
    #[doc = "< result: numa of watershed levels"]
    pub nalevels: *mut Numa,
    #[doc = "< number of seeds (markers)"]
    pub nseeds: l_int32,
    #[doc = "< number of minima different from seeds"]
    pub nother: l_int32,
    #[doc = "< lut for pixel indices"]
    pub lut: *mut l_int32,
    #[doc = "< back-links into lut, for updates"]
    pub links: *mut *mut Numa,
    #[doc = "< size of links array"]
    pub arraysize: l_int32,
    #[doc = "< set to 1 for debug output"]
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_WShed() {
    assert_eq!(
        ::std::mem::size_of::<L_WShed>(),
        152usize,
        concat!("Size of: ", stringify!(L_WShed))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WShed>(),
        8usize,
        concat!("Alignment of ", stringify!(L_WShed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).mindepth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(mindepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixlab as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixlab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).lines8 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lines8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linem1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linelab32 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linelab32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linet1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linet1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).ptas as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(ptas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nasi as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nasi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nash as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).namh as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(namh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nalevels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nalevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nseeds as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nseeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nother as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nother)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).lut as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).links as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).arraysize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(arraysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).debug as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(debug)
        )
    );
}
pub type L_WSHED = L_WShed;
extern "C" {
    pub fn pixCleanBackgroundToWhite(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormSimple(pixs: *mut PIX, pixim: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormGrayArray(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArrays(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormGrayArrayMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArraysMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixm: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFillMapHoles(pix: *mut PIX, nx: l_int32, ny: l_int32, filltype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixExtendByReplication(pixs: *mut PIX, addw: l_int32, addh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSmoothConnectedRegions(pixs: *mut PIX, pixm: *mut PIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetInvBackgroundMap(
        pixs: *mut PIX,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundGrayMap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundRGBMap(
        pixs: *mut PIX,
        pixmr: *mut PIX,
        pixmg: *mut PIX,
        pixmb: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyVariableGrayMap(pixs: *mut PIX, pixg: *mut PIX, target: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        mapval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormNoSatRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        factor: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdSpreadNorm(
        pixs: *mut PIX,
        filtertype: l_int32,
        edgethresh: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
        targetthresh: l_int32,
        ppixth: *mut *mut PIX,
        ppixb: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormFlex(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastNorm(
        pixd: *mut PIX,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        mindiff: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffine(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getAffineXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineInvertXform(vc: *mut l_float32, pvci: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn affineXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelColor(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        colorval: l_uint32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelGray(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        grayval: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn gaussjordan(a: *mut *mut l_float32, b: *mut l_float32, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAffineSequential(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        bw: l_int32,
        bh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn createMatrix2dTranslate(transx: l_float32, transy: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dScale(scalex: l_float32, scaley: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dRotate(xc: l_float32, yc: l_float32, angle: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn ptaTranslate(ptas: *mut PTA, transx: l_float32, transy: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaScale(ptas: *mut PTA, scalex: l_float32, scaley: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaRotate(ptas: *mut PTA, xc: l_float32, yc: l_float32, angle: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaTranslate(boxas: *mut BOXA, transx: l_float32, transy: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaScale(boxas: *mut BOXA, scalex: l_float32, scaley: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaRotate(
        boxas: *mut BOXA,
        xc: l_float32,
        yc: l_float32,
        angle: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn ptaAffineTransform(ptas: *mut PTA, mat: *mut l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaAffineTransform(boxas: *mut BOXA, mat: *mut l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn l_productMatVec(
        mat: *mut l_float32,
        vecs: *mut l_float32,
        vecd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat2(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat3(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat4(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        mat4: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_getDataBit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_clearDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_setDataBitVal(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataDibit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataQbit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataByte(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataByte(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataTwoBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataTwoBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataFourBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataFourBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn barcodeDispatchDecoder(
        barstr: *mut ::std::os::raw::c_char,
        format: l_int32,
        debugflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn barcodeFormatIsSupported(format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixFindBaselines(pixs: *mut PIX, ppta: *mut *mut PTA, pixadb: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixDeskewLocal(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetLocalSkewTransform(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pptas: *mut *mut PTA,
        pptad: *mut *mut PTA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLocalSkewAngles(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pa: *mut l_float32,
        pb: *mut l_float32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bbufferCreate(indata: *const l_uint8, nalloc: l_int32) -> *mut L_BBUFFER;
}
extern "C" {
    pub fn bbufferDestroy(pbb: *mut *mut L_BBUFFER);
}
extern "C" {
    pub fn bbufferDestroyAndSaveData(
        pbb: *mut *mut L_BBUFFER,
        pnbytes: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn bbufferRead(bb: *mut L_BBUFFER, src: *mut l_uint8, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferReadStream(bb: *mut L_BBUFFER, fp: *mut FILE, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferExtendArray(bb: *mut L_BBUFFER, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferWrite(
        bb: *mut L_BBUFFER,
        dest: *mut l_uint8,
        nbytes: size_t,
        pnout: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn bbufferWriteStream(
        bb: *mut L_BBUFFER,
        fp: *mut FILE,
        nbytes: size_t,
        pnout: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBilateral(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGray(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGrayExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockBilateralExact(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRangeKernel(range_stdev: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn pixBilinearSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinear(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getBilinearXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn bilinearXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bilinearXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuAdaptiveThreshold(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskedThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSauvolaBinarizeTiled(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        nx: l_int32,
        ny: l_int32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaBinarize(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        addborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixsd: *mut *mut PIX,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaOnContrastNorm(
        pixs: *mut PIX,
        mindiff: l_int32,
        ppixn: *mut *mut PIX,
        ppixth: *mut *mut PIX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThreshOnDoubleNorm(pixs: *mut PIX, mindiff: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdByConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        start: l_int32,
        end: l_int32,
        incr: l_int32,
        thresh48: l_float32,
        threshdiff: l_float32,
        pglobthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixThresholdByHisto(
        pixs: *mut PIX,
        factor: l_int32,
        halfw: l_int32,
        delta: l_float32,
        pthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        ppixhisto: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExpandBinaryReplicate(pixs: *mut PIX, xfact: l_int32, yfact: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandBinaryPower2(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceBinary2(pixs: *mut PIX, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinaryCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinary2(pixs: *mut PIX, level: l_int32, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn makeSubsampleTab2x() -> *mut l_uint8;
}
extern "C" {
    pub fn pixBlend(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendMask(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGray(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayInverse(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColor(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColorByChannel(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayAdapt(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        shift: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFadeWithGray(
        pixs: *mut PIX,
        pixb: *mut PIX,
        factor: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendHardLight(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendCmap(
        pixs: *mut PIX,
        pixb: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlendWithGrayMask(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        pixg: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBackgroundToColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyByColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAlphaBlendUniform(pixs: *mut PIX, color: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaToBlend(pixs: *mut PIX, fract: l_float32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetAlphaOverWhite(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearEdgeFade(
        pixs: *mut PIX,
        dir: l_int32,
        fadeto: l_int32,
        distfract: l_float32,
        maxfade: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfCreate(dir: *const ::std::os::raw::c_char, fontsize: l_int32) -> *mut L_BMF;
}
extern "C" {
    pub fn bmfDestroy(pbmf: *mut *mut L_BMF);
}
extern "C" {
    pub fn bmfGetPix(bmf: *mut L_BMF, chr: ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn bmfGetWidth(bmf: *mut L_BMF, chr: ::std::os::raw::c_char, pw: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn bmfGetBaseline(
        bmf: *mut L_BMF,
        chr: ::std::os::raw::c_char,
        pbaseline: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetFont(
        dir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
        pbl0: *mut l_int32,
        pbl1: *mut l_int32,
        pbl2: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSaveFont(
        indir: *const ::std::os::raw::c_char,
        outdir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamBmp(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemBmp(cdata: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamBmp(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemBmp(pfdata: *mut *mut l_uint8, pfsize: *mut size_t, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn l_bootnum_gen1() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen2() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen3() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen4(nsamp: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn boxCreate(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCreateValid(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCopy(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxClone(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxDestroy(pbox: *mut *mut BOX);
}
extern "C" {
    pub fn boxGetGeometry(
        box_: *mut BOX,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetGeometry(box_: *mut BOX, x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxGetSideLocations(
        box_: *mut BOX,
        pl: *mut l_int32,
        pr: *mut l_int32,
        pt: *mut l_int32,
        pb: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetSideLocations(
        box_: *mut BOX,
        l: l_int32,
        r: l_int32,
        t: l_int32,
        b: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxGetRefcount(box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxChangeRefcount(box_: *mut BOX, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxIsValid(box_: *mut BOX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaCreate(n: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCopy(boxa: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaDestroy(pboxa: *mut *mut BOXA);
}
extern "C" {
    pub fn boxaAddBox(boxa: *mut BOXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArray(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArrayToSize(boxa: *mut BOXA, size: size_t) -> l_ok;
}
extern "C" {
    pub fn boxaGetCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetValidCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetValidBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindInvalidBoxes(boxa: *mut BOXA) -> *mut NUMA;
}
extern "C" {
    pub fn boxaGetBoxGeometry(
        boxa: *mut BOXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIsFull(boxa: *mut BOXA, pfull: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaReplaceBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaInsertBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBox(boxa: *mut BOXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBoxAndSave(boxa: *mut BOXA, index: l_int32, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaSaveValid(boxas: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaInitFull(boxa: *mut BOXA, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaClear(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaCreate(n: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaCopy(baas: *mut BOXAA, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaDestroy(pbaa: *mut *mut BOXAA);
}
extern "C" {
    pub fn boxaaAddBoxa(baa: *mut BOXAA, ba: *mut BOXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArray(baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArrayToSize(baa: *mut BOXAA, size: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxa(baa: *mut BOXAA, index: l_int32, accessflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaGetBox(
        baa: *mut BOXAA,
        iboxa: l_int32,
        ibox: l_int32,
        accessflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaaInitFull(baa: *mut BOXAA, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendWithInit(baa: *mut BOXAA, maxindex: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaReplaceBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaInsertBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaRemoveBoxa(baa: *mut BOXAA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaAddBox(
        baa: *mut BOXAA,
        index: l_int32,
        box_: *mut BOX,
        accessflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadStream(fp: *mut FILE) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadMem(data: *const l_uint8, size: size_t) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaWrite(filename: *const ::std::os::raw::c_char, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteStream(fp: *mut FILE, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadStream(fp: *mut FILE) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadMem(data: *const l_uint8, size: size_t) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWriteDebug(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWrite(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStream(fp: *mut FILE, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStderr(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxPrintStreamInfo(fp: *mut FILE, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxContains(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxIntersects(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaContainedInBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBoxa(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        pcontained: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIntersectsBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaIntersectsBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaClipToBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlaps(boxas: *mut BOXA, pixadb: *mut PIXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlapsInPair(
        boxas1: *mut BOXA,
        boxas2: *mut BOXA,
        pboxad1: *mut *mut BOXA,
        pboxad2: *mut *mut BOXA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxOverlapRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxBoundingRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxOverlapFraction(box1: *mut BOX, box2: *mut BOX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxOverlapArea(box1: *mut BOX, box2: *mut BOX, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaHandleOverlaps(
        boxas: *mut BOXA,
        op: l_int32,
        range: l_int32,
        min_overlap: l_float32,
        max_ratio: l_float32,
        pnamap: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxOverlapDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_ovl: *mut l_int32,
        pv_ovl: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSeparationDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_sep: *mut l_int32,
        pv_sep: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxCompareSize(
        box1: *mut BOX,
        box2: *mut BOX,
        type_: l_int32,
        prel: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxContainsPt(
        box_: *mut BOX,
        x: l_float32,
        y: l_float32,
        pcontains: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestToPt(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetNearestToLine(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindNearestBoxes(
        boxa: *mut BOXA,
        dist_select: l_int32,
        range: l_int32,
        pnaaindex: *mut *mut NUMAA,
        pnaadist: *mut *mut NUMAA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestByDirection(
        boxa: *mut BOXA,
        i: l_int32,
        dir: l_int32,
        dist_select: l_int32,
        range: l_int32,
        pindex: *mut l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxGetCenter(box_: *mut BOX, pcx: *mut l_float32, pcy: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxIntersectByLine(
        box_: *mut BOX,
        x: l_int32,
        y: l_int32,
        slope: l_float32,
        px1: *mut l_int32,
        py1: *mut l_int32,
        px2: *mut l_int32,
        py2: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxClipToRectangle(box_: *mut BOX, wi: l_int32, hi: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxClipToRectangleParams(
        box_: *mut BOX,
        w: l_int32,
        h: l_int32,
        pxstart: *mut l_int32,
        pystart: *mut l_int32,
        pxend: *mut l_int32,
        pyend: *mut l_int32,
        pbw: *mut l_int32,
        pbh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxRelocateOneSide(
        boxd: *mut BOX,
        boxs: *mut BOX,
        loc: l_int32,
        sideflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaAdjustSides(
        boxas: *mut BOXA,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustBoxSides(
        boxa: *mut BOXA,
        index: l_int32,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxAdjustSides(
        boxd: *mut BOX,
        boxs: *mut BOX,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSetSide(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        side: l_int32,
        val: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxSetSide(boxs: *mut BOX, side: l_int32, val: l_int32, thresh: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaAdjustWidthToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustHeightToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxEqual(box1: *mut BOX, box2: *mut BOX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaEqual(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSimilar(
        box1: *mut BOX,
        box2: *mut BOX,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        psimilar: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSimilar(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        debug: l_int32,
        psimilar: *mut l_int32,
        pnasim: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaJoin(boxad: *mut BOXA, boxas: *mut BOXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaJoin(baad: *mut BOXAA, baas: *mut BOXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaSplitEvenOdd(
        boxa: *mut BOXA,
        fillflag: l_int32,
        pboxae: *mut *mut BOXA,
        pboxao: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMergeEvenOdd(boxae: *mut BOXA, boxao: *mut BOXA, fillflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaTransform(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransform(
        box_: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaTransformOrdered(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransformOrdered(
        boxs: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaRotateOrth(boxas: *mut BOXA, w: l_int32, h: l_int32, rotation: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxRotateOrth(box_: *mut BOX, w: l_int32, h: l_int32, rotation: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaShiftWithPta(boxas: *mut BOXA, pta: *mut PTA, dir: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaBinSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSortByIndex(boxas: *mut BOXA, naindex: *mut NUMA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort2d(
        boxas: *mut BOXA,
        pnaad: *mut *mut NUMAA,
        delta1: l_int32,
        delta2: l_int32,
        minh1: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSort2dByIndex(boxas: *mut BOXA, naa: *mut NUMAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaExtractAsNuma(
        boxa: *mut BOXA,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractAsPta(
        boxa: *mut BOXA,
        pptal: *mut *mut PTA,
        pptat: *mut *mut PTA,
        pptar: *mut *mut PTA,
        pptab: *mut *mut PTA,
        pptaw: *mut *mut PTA,
        pptah: *mut *mut PTA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractCorners(boxa: *mut BOXA, loc: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn boxaGetRankVals(
        boxa: *mut BOXA,
        fract: l_float32,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetMedianVals(
        boxa: *mut BOXA,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetAverageSize(boxa: *mut BOXA, pw: *mut l_float32, ph: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetExtent(
        baa: *mut BOXAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaFlattenToBoxa(
        baa: *mut BOXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaFlattenAligned(
        baa: *mut BOXAA,
        num: l_int32,
        fillerbox: *mut BOX,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaEncapsulateAligned(boxa: *mut BOXA, num: l_int32, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaTranspose(baas: *mut BOXAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaAlignBox(
        baa: *mut BOXAA,
        box_: *mut BOX,
        delta: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMaskConnComp(
        pixs: *mut PIX,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskBoxa(pixd: *mut PIX, pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxa(pixs: *mut PIX, boxa: *mut BOXA, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetBlackOrWhiteBoxa(pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxa(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn boxaaDisplay(
        pixs: *mut PIX,
        baa: *mut BOXAA,
        linewba: l_int32,
        linewb: l_int32,
        colorba: l_uint32,
        colorb: l_uint32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayBoxaa(
        pixas: *mut PIXA,
        baa: *mut BOXAA,
        colorflag: l_int32,
        width: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSplitIntoBoxa(
        pixs: *mut PIX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixSplitComponentIntoBoxa(
        pix: *mut PIX,
        box_: *mut BOX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn makeMosaicStrips(w: l_int32, h: l_int32, direction: l_int32, size: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxaCompareRegions(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        areathresh: l_int32,
        pnsame: *mut l_int32,
        pdiffarea: *mut l_float32,
        pdiffxor: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectLargeULComp(
        pixs: *mut PIX,
        areaslop: l_float32,
        yslop: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectLargeULBox(boxas: *mut BOXA, areaslop: l_float32, yslop: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectRange(
        boxas: *mut BOXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaSelectRange(
        baas: *mut BOXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSelectBySize(
        boxas: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeSizeIndicator(
        boxa: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByArea(
        boxas: *mut BOXA,
        area: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeAreaIndicator(boxa: *mut BOXA, area: l_int32, relation: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByWHRatio(
        boxas: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeWHRatioIndicator(
        boxa: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectWithIndicator(
        boxas: *mut BOXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermutePseudorandom(boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermuteRandom(boxad: *mut BOXA, boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSwapBoxes(boxa: *mut BOXA, i: l_int32, j: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaConvertToPta(boxa: *mut BOXA, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBoxa(pta: *mut PTA, ncorners: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxConvertToPta(box_: *mut BOX, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBox(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetExtent(
        boxa: *mut BOXA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetCoverage(
        boxa: *mut BOXA,
        wc: l_int32,
        hc: l_int32,
        exactflag: l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaSizeRange(
        baa: *mut BOXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSizeRange(
        boxa: *mut BOXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaLocationRange(
        boxa: *mut BOXA,
        pminx: *mut l_int32,
        pminy: *mut l_int32,
        pmaxx: *mut l_int32,
        pmaxy: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetSizes(boxa: *mut BOXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn boxaGetArea(boxa: *mut BOXA, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaDisplayTiled(
        boxas: *mut BOXA,
        pixa: *mut PIXA,
        first: l_int32,
        last: l_int32,
        maxwidth: l_int32,
        linewidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn boxaSmoothSequenceMedian(
        boxas: *mut BOXA,
        halfwin: l_int32,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
        debug: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWindowedMedian(boxas: *mut BOXA, halfwin: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaModifyWithBoxa(
        boxas: *mut BOXA,
        boxam: *mut BOXA,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcilePairWidth(
        boxas: *mut BOXA,
        delw: l_int32,
        op: l_int32,
        factor: l_float32,
        na: *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeConsistency(
        boxas: *mut BOXA,
        type_: l_int32,
        threshp: l_float32,
        threshm: l_float32,
        pfvarp: *mut l_float32,
        pfvarm: *mut l_float32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaReconcileAllByMedian(
        boxas: *mut BOXA,
        select1: l_int32,
        select2: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSidesByMedian(
        boxas: *mut BOXA,
        select: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSizeByMedian(
        boxas: *mut BOXA,
        type_: l_int32,
        dfract: l_float32,
        sfract: l_float32,
        factor: l_float32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
        pratiowh: *mut l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPlotSides(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaPlotSizes(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaFillSequence(boxas: *mut BOXA, useflag: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeVariation(
        boxa: *mut BOXA,
        type_: l_int32,
        pdel_evenodd: *mut l_float32,
        prms_even: *mut l_float32,
        prms_odd: *mut l_float32,
        prms_all: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMedianDimensions(
        boxas: *mut BOXA,
        pmedw: *mut l_int32,
        pmedh: *mut l_int32,
        pmedwe: *mut l_int32,
        pmedwo: *mut l_int32,
        pmedhe: *mut l_int32,
        pmedho: *mut l_int32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaCreate(nbytes: size_t) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromMem(data: *const l_uint8, size: size_t) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromFile(fname: *const ::std::os::raw::c_char) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromStream(fp: *mut FILE) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaCopy(bas: *mut L_BYTEA, copyflag: l_int32) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaDestroy(pba: *mut *mut L_BYTEA);
}
extern "C" {
    pub fn l_byteaGetSize(ba: *mut L_BYTEA) -> size_t;
}
extern "C" {
    pub fn l_byteaGetData(ba: *mut L_BYTEA, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaCopyData(ba: *mut L_BYTEA, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaAppendData(ba: *mut L_BYTEA, newdata: *const l_uint8, newbytes: size_t) -> l_ok;
}
extern "C" {
    pub fn l_byteaAppendString(ba: *mut L_BYTEA, str_: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn l_byteaJoin(ba1: *mut L_BYTEA, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaSplit(ba1: *mut L_BYTEA, splitloc: size_t, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaFindEachSequence(
        ba: *mut L_BYTEA,
        sequence: *const l_uint8,
        seqlen: size_t,
        pda: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWrite(
        fname: *const ::std::os::raw::c_char,
        ba: *mut L_BYTEA,
        startloc: size_t,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWriteStream(
        fp: *mut FILE,
        ba: *mut L_BYTEA,
        startloc: size_t,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn ccbaCreate(pixs: *mut PIX, n: l_int32) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaDestroy(pccba: *mut *mut CCBORDA);
}
extern "C" {
    pub fn ccbCreate(pixs: *mut PIX) -> *mut CCBORD;
}
extern "C" {
    pub fn ccbDestroy(pccb: *mut *mut CCBORD);
}
extern "C" {
    pub fn ccbaAddCcb(ccba: *mut CCBORDA, ccb: *mut CCBORD) -> l_ok;
}
extern "C" {
    pub fn ccbaGetCount(ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaGetCcb(ccba: *mut CCBORDA, index: l_int32) -> *mut CCBORD;
}
extern "C" {
    pub fn pixGetAllCCBorders(pixs: *mut PIX) -> *mut CCBORDA;
}
extern "C" {
    pub fn pixGetOuterBordersPtaa(pixs: *mut PIX) -> *mut PTAA;
}
extern "C" {
    pub fn pixGetOuterBorder(ccb: *mut CCBORD, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateGlobalLocs(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateStepChains(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaStepChainsToPixCoords(ccba: *mut CCBORDA, coordtype: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSPGlobalLocs(ccba: *mut CCBORDA, ptsflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSinglePath(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn getCutPathForHole(
        pix: *mut PIX,
        pta: *mut PTA,
        boxinner: *mut BOX,
        pdir: *mut l_int32,
        plen: *mut l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ccbaDisplayBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplaySPBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage1(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage2(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaWrite(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteStream(fp: *mut FILE, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaRead(filename: *const ::std::os::raw::c_char) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaReadStream(fp: *mut FILE) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaWriteSVG(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteSVGString(ccba: *mut CCBORDA) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixaThinConnected(
        pixas: *mut PIXA,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixThinConnected(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThinConnectedBySet(
        pixs: *mut PIX,
        type_: l_int32,
        sela: *mut SELA,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaMakeThinSets(index: l_int32, debug: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn pixFindCheckerboardCorners(
        pixs: *mut PIX,
        size: l_int32,
        dilation: l_int32,
        nsels: l_int32,
        ppix_corners: *mut *mut PIX,
        ppta_corners: *mut *mut PTA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbCorrelation(
        dirin: *const ::std::os::raw::c_char,
        thresh: l_float32,
        weight: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbRankHaus(
        dirin: *const ::std::os::raw::c_char,
        size: l_int32,
        rank: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbWordsInTextlines(
        dirin: *const ::std::os::raw::c_char,
        reduction: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weight: l_float32,
        pnatl: *mut *mut NUMA,
        firstpage: l_int32,
        npages: l_int32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn pixGetWordsInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetWordBoxesInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindWordAndCharacterBoxes(
        pixs: *mut PIX,
        boxs: *mut BOX,
        thresh: l_int32,
        pboxaw: *mut *mut BOXA,
        pboxaac: *mut *mut BOXAA,
        debugdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractSortedPattern(boxa: *mut BOXA, na: *mut NUMA) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCompareImagesByBoxes(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        nperline: l_int32,
        nreq: l_int32,
        maxshiftx: l_int32,
        maxshifty: l_int32,
        delx: l_int32,
        dely: l_int32,
        psame: *mut l_int32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorContent(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        mingray: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorMagnitude(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorFraction(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        factor: l_int32,
        ppixfract: *mut l_float32,
        pcolorfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorShiftWhitePoint(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorPixels(
        pixs: *mut PIX,
        threshdiff: l_int32,
        mindist: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverGrayPixels(pixs: *mut PIX, maxlimit: l_int32, satlimit: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorRange(
        pixs: *mut PIX,
        rmin: l_int32,
        rmax: l_int32,
        gmin: l_int32,
        gmax: l_int32,
        bmin: l_int32,
        bmax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindColorRegions(
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_int32,
        lightthresh: l_int32,
        darkthresh: l_int32,
        mindiff: l_int32,
        colordiff: l_int32,
        edgefract: l_float32,
        pcolorfract: *mut l_float32,
        pcolormask1: *mut *mut PIX,
        pcolormask2: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumSignificantGrayColors(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        minfract: l_float32,
        factor: l_int32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorsForQuantization(
        pixs: *mut PIX,
        thresh: l_int32,
        pncolors: *mut l_int32,
        piscolor: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToCmapLossless(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetMostPopulatedColors(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
        parray: *mut *mut l_uint32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSimpleColorQuantize(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBHistogram(pixs: *mut PIX, sigbits: l_int32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn makeRGBIndexTables(
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
        sigbits: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn getRGBFromIndex(
        index: l_uint32,
        sigbits: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHasHighlightRed(
        pixs: *mut PIX,
        factor: l_int32,
        minfract: l_float32,
        fthresh: l_float32,
        phasred: *mut l_int32,
        pratio: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_colorfillCreate(pixs: *mut PIX, nx: l_int32, ny: l_int32) -> *mut L_COLORFILL;
}
extern "C" {
    pub fn l_colorfillDestroy(pcf: *mut *mut L_COLORFILL);
}
extern "C" {
    pub fn pixColorContentByLocation(
        cf: *mut L_COLORFILL,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        minmax: l_int32,
        maxdiff: l_int32,
        minarea: l_int32,
        smooth: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorFill(
        pixs: *mut PIX,
        minmax: l_int32,
        maxdiff: l_int32,
        smooth: l_int32,
        minarea: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeColorfillTestData(
        w: l_int32,
        h: l_int32,
        nseeds: l_int32,
        range: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixColorGrayRegions(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorGray(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColorCmap(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearMapToTargetColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelLinearMapToTargetColor(
        scolor: l_uint32,
        srcmap: l_uint32,
        dstmap: l_uint32,
        pdcolor: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixShiftByComponent(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelShiftByComponent(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        srcval: l_uint32,
        dstval: l_uint32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixelFractionalShift(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMapWithInvariantHue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixcmapCreate(depth: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateRandom(
        depth: l_int32,
        hasblack: l_int32,
        haswhite: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateLinear(d: l_int32, nlevels: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCopy(cmaps: *const PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapDestroy(pcmap: *mut *mut PIXCMAP);
}
extern "C" {
    pub fn pixcmapIsValid(cmap: *const PIXCMAP, pix: *mut PIX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddColor(cmap: *mut PIXCMAP, rval: l_int32, gval: l_int32, bval: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapAddRGBA(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNewColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNearestColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapUsableColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pusable: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddBlackOrWhite(cmap: *mut PIXCMAP, color: l_int32, pindex: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapSetBlackAndWhite(
        cmap: *mut PIXCMAP,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetCount(cmap: *const PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetFreeCount(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetDepth(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetMinDepth(cmap: *mut PIXCMAP, pmindepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapClear(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapResetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSetAlpha(cmap: *mut PIXCMAP, index: l_int32, aval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapHasColor(cmap: *mut PIXCMAP, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsOpaque(cmap: *mut PIXCMAP, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapNonOpaqueColorsInfo(
        cmap: *mut PIXCMAP,
        pntrans: *mut l_int32,
        pmax_trans: *mut l_int32,
        pmin_opaque: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsBlackAndWhite(cmap: *mut PIXCMAP, pblackwhite: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapCountGrayColors(cmap: *mut PIXCMAP, pngray: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRankIntensity(
        cmap: *mut PIXCMAP,
        rankval: l_float32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestGrayIndex(
        cmap: *mut PIXCMAP,
        val: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetDistanceToColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRangeValues(
        cmap: *mut PIXCMAP,
        select: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pminindex: *mut l_int32,
        pmaxindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGrayToFalseColor(gamma: l_float32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapGrayToColor(color: l_uint32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapColorToGray(
        cmaps: *mut PIXCMAP,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo4(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo8(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapRead(filename: *const ::std::os::raw::c_char) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadStream(fp: *mut FILE) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadMem(data: *const l_uint8, size: size_t) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapWrite(filename: *const ::std::os::raw::c_char, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteStream(fp: *mut FILE, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        cmap: *const PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToArrays(
        cmap: *const PIXCMAP,
        prmap: *mut *mut l_int32,
        pgmap: *mut *mut l_int32,
        pbmap: *mut *mut l_int32,
        pamap: *mut *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToRGBTable(
        cmap: *mut PIXCMAP,
        ptab: *mut *mut l_uint32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSerializeToMemory(
        cmap: *mut PIXCMAP,
        cpc: l_int32,
        pncolors: *mut l_int32,
        pdata: *mut *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapDeserializeFromMemory(
        data: *mut l_uint8,
        cpc: l_int32,
        ncolors: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertToHex(data: *mut l_uint8, ncolors: l_int32)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixcmapGammaTRC(
        cmap: *mut PIXCMAP,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapContrastTRC(cmap: *mut PIXCMAP, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftIntensity(cmap: *mut PIXCMAP, fraction: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftByComponent(cmap: *mut PIXCMAP, srcval: l_uint32, dstval: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixColorMorph(
        pixs: *mut PIX,
        type_: l_int32,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuant(pixs: *mut PIX, colors: l_int32, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuantGeneral(
        pixs: *mut PIX,
        colors: l_int32,
        ditherflag: l_int32,
        validthresh: l_float32,
        colorthresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRGBToIndexTables(
        cqlevels: l_int32,
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn getOctcubeIndexFromRGB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        rtab: *mut l_uint32,
        gtab: *mut l_uint32,
        btab: *mut l_uint32,
        pindex: *mut l_uint32,
    );
}
extern "C" {
    pub fn pixOctreeQuantByPopulation(
        pixs: *mut PIX,
        level: l_int32,
        ditherflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeQuantNumColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        subsample: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantMixedWithGray(
        pixs: *mut PIX,
        depth: l_int32,
        graylevels: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuant256(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant1(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant2(
        pixs: *mut PIX,
        level: l_int32,
        na: *mut NUMA,
        ncolors: l_int32,
        pnerrors: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuantMixed(
        pixs: *mut PIX,
        level: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        minfract: l_float32,
        maxspan: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuantGenRGB(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeHistogram(pixs: *mut PIX, level: l_int32, pncolors: *mut l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixcmapToOctcubeLUT(cmap: *mut PIXCMAP, level: l_int32, metric: l_int32)
        -> *mut l_int32;
}
extern "C" {
    pub fn pixRemoveUnusedColors(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixNumberOccupiedOctcubes(
        pix: *mut PIX,
        level: l_int32,
        mincount: l_int32,
        minfract: l_float32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMedianCutQuant(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantGeneral(
        pixs: *mut PIX,
        ditherflag: l_int32,
        outdepth: l_int32,
        maxcolors: l_int32,
        sigbits: l_int32,
        maxsub: l_int32,
        checkbw: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        maxncolors: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutHisto(pixs: *mut PIX, sigbits: l_int32, subsample: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn pixColorSegment(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        selsize: l_int32,
        finalcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorSegmentCluster(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAssignToNearestColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        level: l_int32,
        countarray: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentClean(pixs: *mut PIX, selsize: l_int32, countarray: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentRemoveColors(
        pixd: *mut PIX,
        pixs: *mut PIX,
        finalcolors: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHSV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertHSVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToHSV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        phval: *mut l_int32,
        psval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertHSVToRGB(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToHSV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertHSVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToSaturation(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToValue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHS(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        satcenter: l_int32,
        sathw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHV(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskSV(
        pixs: *mut PIX,
        satcenter: l_int32,
        sathw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHS(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnasat: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHV(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoSV(
        pixs: *mut PIX,
        factor: l_int32,
        pnasat: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHistoPeaksHSV(
        pixs: *mut PIX,
        type_: l_int32,
        width: l_int32,
        height: l_int32,
        npeaks: l_int32,
        erasefactor: l_float32,
        ppta: *mut *mut PTA,
        pnatot: *mut *mut NUMA,
        ppixa: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn displayHSVColorRange(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        huehw: l_int32,
        sathw: l_int32,
        nsamp: l_int32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToYUV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertYUVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToYUV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pyval: *mut l_int32,
        puval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertYUVToRGB(
        yval: l_int32,
        uval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToYUV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertYUVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToXYZ(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertXYZToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToXYZ(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pfxval: *mut l_float32,
        pfyval: *mut l_float32,
        pfzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertXYZToRGB(
        fxval: l_float32,
        fyval: l_float32,
        fzval: l_float32,
        blackout: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaConvertXYZToLAB(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToXYZ(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn convertXYZToLAB(
        xval: l_float32,
        yval: l_float32,
        zval: l_float32,
        plval: *mut l_float32,
        paval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToXYZ(
        lval: l_float32,
        aval: l_float32,
        bval: l_float32,
        pxval: *mut l_float32,
        pyval: *mut l_float32,
        pzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToLAB(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToLAB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pflval: *mut l_float32,
        pfaval: *mut l_float32,
        pfbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToRGB(
        flval: l_float32,
        faval: l_float32,
        fbval: l_float32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeGamutRGB(scale: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixEqual(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithAlpha(
        pix1: *mut PIX,
        pix2: *mut PIX,
        use_alpha: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithCmap(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn cmapEqual(
        cmap1: *mut PIXCMAP,
        cmap2: *mut PIXCMAP,
        ncomps: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUsesCmapColor(pixs: *mut PIX, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationBinary(pix1: *mut PIX, pix2: *mut PIX, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayDiffBinary(pix1: *mut PIX, pix2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCompareBinary(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        pfract: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayOrRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGray(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareTiled(
        pix1: *mut PIX,
        pix2: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRankDifference(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTestForSimilarity(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        maxfract: l_float32,
        maxave: l_float32,
        psimilar: *mut l_int32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceStats(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        pfractdiff: *mut l_float32,
        pavediff: *mut l_float32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceHistogram(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetPerceptualDiff(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        sampling: l_int32,
        dilation: l_int32,
        mindiff: l_int32,
        pfract: *mut l_float32,
        ppixdiff1: *mut *mut PIX,
        ppixdiff2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPSNR(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        ppsnr: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaComparePhotoRegionsByHisto(
        pixa: *mut PIXA,
        minratio: l_float32,
        textthresh: l_float32,
        factor: l_int32,
        n: l_int32,
        simthresh: l_float32,
        pnai: *mut *mut NUMA,
        pscores: *mut *mut l_float32,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixComparePhotoRegionsByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenPhotoHistos(
        pixs: *mut PIX,
        box_: *mut BOX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        debugindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPadToCenterCentroid(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCentroid8(
        pixs: *mut PIX,
        factor: l_int32,
        pcx: *mut l_float32,
        pcy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfPhotoImage(
        pix: *mut PIX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn compareTilesByHisto(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        minratio: l_float32,
        w1: l_int32,
        h1: l_int32,
        w2: l_int32,
        h2: l_int32,
        pscore: *mut l_float32,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        maxgray: l_int32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropAlignedToCentroid(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        pbox1: *mut *mut BOX,
        pbox2: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_compressGrayHistograms(
        naa: *mut NUMAA,
        w: l_int32,
        h: l_int32,
        psize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_uncompressGrayHistograms(
        bytea: *mut l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixCompareWithTranslation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        thresh: l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBestCorrelation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        etransx: l_int32,
        etransy: l_int32,
        maxshift: l_int32,
        tab8: *mut l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnComp(pixs: *mut PIX, ppixa: *mut *mut PIXA, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompPixa(
        pixs: *mut PIX,
        ppixa: *mut *mut PIXA,
        connectivity: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompBB(pixs: *mut PIX, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixCountConnComp(pixs: *mut PIX, connectivity: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn nextOnPixelInRaster(
        pixs: *mut PIX,
        xstart: l_int32,
        ystart: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillBB(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill4BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill8BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill4(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill8(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn convertFilesTo1bpp(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        upscaling: l_int32,
        thresh: l_int32,
        firstpage: l_int32,
        npages: l_int32,
        dirout: *const ::std::os::raw::c_char,
        outformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlockconv(pix: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGray(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvAccum(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayUnnormalized(pixs: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvTiled(
        pix: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayTile(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedStats(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixms: *mut *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWindowedMean(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedMeanSquare(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedVariance(
        pixm: *mut PIX,
        pixms: *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanSquareAccum(pixs: *mut PIX) -> *mut DPIX;
}
extern "C" {
    pub fn pixBlockrank(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlocksum(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCensusTransform(pixs: *mut PIX, halfsize: l_int32, pixacc: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolve(
        pixs: *mut PIX,
        kel: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveSep(
        pixs: *mut PIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGB(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGBSep(pixs: *mut PIX, kelx: *mut L_KERNEL, kely: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvolve(fpixs: *mut FPIX, kel: *mut L_KERNEL, normflag: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixConvolveSep(
        fpixs: *mut FPIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        normflag: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvolveWithBias(
        pixs: *mut PIX,
        kel1: *mut L_KERNEL,
        kel2: *mut L_KERNEL,
        force8: l_int32,
        pbias: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setConvolveSampling(xfact: l_int32, yfact: l_int32);
}
extern "C" {
    pub fn pixAddGaussianNoise(pixs: *mut PIX, stdev: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn gaussDistribSampling() -> l_float32;
}
extern "C" {
    pub fn pixCorrelationScore(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreThresholded(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        downcount: *mut l_int32,
        score_threshold: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreSimple(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreShifted(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_int32,
        dely: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpCreate(pixs: *mut PIX, pageno: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpCreateRef(pageno: l_int32, refpage: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpDestroy(pdew: *mut *mut L_DEWARP);
}
extern "C" {
    pub fn dewarpaCreate(
        nptrs: l_int32,
        sampling: l_int32,
        redfactor: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaCreateFromPixacomp(
        pixac: *mut PIXAC,
        useboth: l_int32,
        sampling: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaDestroy(pdewa: *mut *mut L_DEWARPA);
}
extern "C" {
    pub fn dewarpaDestroyDewarp(dewa: *mut L_DEWARPA, pageno: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertDewarp(dewa: *mut L_DEWARPA, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpaGetDewarp(dewa: *mut L_DEWARPA, index: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpaSetCurvatures(
        dewa: *mut L_DEWARPA,
        max_linecurv: l_int32,
        min_diff_linecurv: l_int32,
        max_diff_linecurv: l_int32,
        max_edgecurv: l_int32,
        max_diff_edgecurv: l_int32,
        max_edgeslope: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaUseBothArrays(dewa: *mut L_DEWARPA, useboth: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetCheckColumns(dewa: *mut L_DEWARPA, check_columns: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetMaxDistance(dewa: *mut L_DEWARPA, maxdist: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadStream(fp: *mut FILE) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadMem(data: *const l_uint8, size: size_t) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpWrite(filename: *const ::std::os::raw::c_char, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteStream(fp: *mut FILE, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, dew: *mut L_DEWARP)
        -> l_ok;
}
extern "C" {
    pub fn dewarpaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadStream(fp: *mut FILE) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaWrite(filename: *const ::std::os::raw::c_char, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteStream(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        dewa: *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildPageModel(
        dew: *mut L_DEWARP,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpFindVertDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA, rotflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpFindHorizDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn dewarpGetTextlineCenters(pixs: *mut PIX, debugflag: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpRemoveShortLines(
        pixs: *mut PIX,
        ptaas: *mut PTAA,
        fract: l_float32,
        debugflag: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpFindHorizSlopeDisparity(
        dew: *mut L_DEWARP,
        pixb: *mut PIX,
        fractthresh: l_float32,
        parity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildLineModel(
        dew: *mut L_DEWARP,
        opensize: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStatus(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pvsuccess: *mut l_int32,
        phsuccess: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparity(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        grayin: l_int32,
        x: l_int32,
        y: l_int32,
        ppixd: *mut *mut PIX,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparityBoxa(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        mapdir: l_int32,
        x: l_int32,
        y: l_int32,
        pboxad: *mut *mut BOXA,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpMinimize(dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpPopulateFullRes(dew: *mut L_DEWARP, pix: *mut PIX, x: l_int32, y: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePage(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixd: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageInit(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixb: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageRun(
        pixs: *mut PIX,
        pixb: *mut PIX,
        dewa: *mut L_DEWARPA,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaListPages(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetValidModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertRefModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaStripRefModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaRestoreModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaInfo(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStats(
        dewa: *mut L_DEWARPA,
        pnnone: *mut l_int32,
        pnvsuccess: *mut l_int32,
        pnvvalid: *mut l_int32,
        pnhsuccess: *mut l_int32,
        pnhvalid: *mut l_int32,
        pnref: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaShowArrays(
        dewa: *mut L_DEWARPA,
        scalefact: l_float32,
        first: l_int32,
        last: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpDebug(
        dew: *mut L_DEWARP,
        subdirs: *const ::std::os::raw::c_char,
        index: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpShowResults(
        dewa: *mut L_DEWARPA,
        sa: *mut SARRAY,
        boxa: *mut BOXA,
        firstpage: l_int32,
        lastpage: l_int32,
        pdfout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaCreate(n: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromDArray(
        darray: *mut l_float64,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaMakeSequence(
        startval: l_float64,
        increment: l_float64,
        size: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaDestroy(pda: *mut *mut L_DNA);
}
extern "C" {
    pub fn l_dnaCopy(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaClone(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaEmpty(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaAddNumber(da: *mut L_DNA, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaInsertNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaRemoveNumber(da: *mut L_DNA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaReplaceNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetCount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetCount(da: *mut L_DNA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetDValue(da: *mut L_DNA, index: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIValue(da: *mut L_DNA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetValue(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaShiftValue(da: *mut L_DNA, index: l_int32, diff: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIArray(da: *mut L_DNA) -> *mut l_int32;
}
extern "C" {
    pub fn l_dnaGetDArray(da: *mut L_DNA, copyflag: l_int32) -> *mut l_float64;
}
extern "C" {
    pub fn l_dnaGetRefcount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaChangeRefcount(da: *mut L_DNA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetParameters(
        da: *mut L_DNA,
        pstartx: *mut l_float64,
        pdelx: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetParameters(da: *mut L_DNA, startx: l_float64, delx: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaCopyParameters(dad: *mut L_DNA, das: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadStream(fp: *mut FILE) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaWrite(filename: *const ::std::os::raw::c_char, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStream(fp: *mut FILE, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStderr(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaCreate(n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaCreateFull(nptr: l_int32, n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaTruncate(daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaDestroy(pdaa: *mut *mut L_DNAA);
}
extern "C" {
    pub fn l_dnaaAddDna(daa: *mut L_DNAA, da: *mut L_DNA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDnaCount(daa: *mut L_DNAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetNumberCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDna(daa: *mut L_DNAA, index: l_int32, accessflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaaReplaceDna(daa: *mut L_DNAA, index: l_int32, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetValue(daa: *mut L_DNAA, i: l_int32, j: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaAddNumber(daa: *mut L_DNAA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadStream(fp: *mut FILE) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaWrite(filename: *const ::std::os::raw::c_char, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteStream(fp: *mut FILE, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaJoin(dad: *mut L_DNA, das: *mut L_DNA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaFlattenToDna(daa: *mut L_DNAA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaSelectRange(das: *mut L_DNA, first: l_int32, last: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaConvertToNuma(da: *mut L_DNA) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToDna(na: *mut NUMA) -> *mut L_DNA;
}
extern "C" {
    pub fn pixConvertDataToDna(pix: *mut PIX) -> *mut L_DNA;
}
extern "C" {
    pub fn l_asetCreateFromDna(da: *mut L_DNA) -> *mut L_ASET;
}
extern "C" {
    pub fn l_dnaRemoveDupsByAset(das: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromDna(da: *mut L_DNA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_dnaRemoveDupsByHmap(
        das: *mut L_DNA,
        pdad: *mut *mut L_DNA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_dnaMakeHistoByHmap(
        das: *mut L_DNA,
        pdav: *mut *mut L_DNA,
        pdac: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaDiffAdjValues(das: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashCreate(nbuckets: l_int32, initsize: l_int32) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn l_dnaHashDestroy(pdahash: *mut *mut L_DNAHASH);
}
extern "C" {
    pub fn l_dnaHashGetDna(dahash: *mut L_DNAHASH, key: l_uint64, copyflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashAdd(dahash: *mut L_DNAHASH, key: l_uint64, value: l_float64) -> l_ok;
}
extern "C" {
    pub fn pixMorphDwa_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_2(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSobelEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTwoSidedEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureEdgeSmoothness(
        pixs: *mut PIX,
        side: l_int32,
        minjump: l_int32,
        minreversal: l_int32,
        pjpl: *mut l_float32,
        pjspl: *mut l_float32,
        prpl: *mut l_float32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetEdgeProfile(
        pixs: *mut PIX,
        side: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetLastOffPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLastOnPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn encodeBase64(
        inarray: *const l_uint8,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeBase64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85(
        inarray: *const l_uint8,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85(
        inarray: *const ::std::os::raw::c_char,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85WithComp(
        indata: *const l_uint8,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85WithComp(
        instr: *const ::std::os::raw::c_char,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn reformatPacked64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        leadspace: l_int32,
        linechars: l_int32,
        addquotes: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixGammaTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCWithAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaGammaTRC(gamma: l_float32, minval: l_int32, maxval: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixContrastTRC(pixd: *mut PIX, pixs: *mut PIX, factor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaContrastTRC(factor: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn pixEqualizeTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        fract: l_float32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaEqualizeTRC(pix: *mut PIX, fract: l_float32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTRCMap(pixs: *mut PIX, pixm: *mut PIX, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixTRCMapGeneral(
        pixs: *mut PIX,
        pixm: *mut PIX,
        nar: *mut NUMA,
        nag: *mut NUMA,
        nab: *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUnsharpMasking(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGrayFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray1D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray2D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixModifyHue(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixModifySaturation(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureSaturation(pixs: *mut PIX, factor: l_int32, psat: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixModifyBrightness(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMosaicColorShiftRGB(
        pixs: *mut PIX,
        roff: l_float32,
        goff: l_float32,
        boff: l_float32,
        delta: l_float32,
        nincr: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorShiftRGB(
        pixs: *mut PIX,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDarkenGray(
        pixd: *mut PIX,
        pixs: *mut PIX,
        thresh: l_int32,
        satlimit: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultConstantColor(
        pixs: *mut PIX,
        rfact: l_float32,
        gfact: l_float32,
        bfact: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultMatrixColor(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHalfEdgeByBandpass(
        pixs: *mut PIX,
        sm1h: l_int32,
        sm1v: l_int32,
        sm2h: l_int32,
        sm2v: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHMTDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFHMTGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixItalicWords(
        pixs: *mut PIX,
        boxaw: *mut BOXA,
        pixw: *mut PIX,
        pboxa: *mut *mut BOXA,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOrientCorrect(
        pixs: *mut PIX,
        minupconf: l_float32,
        minratio: l_float32,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        protation: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOrientDetect(
        pixs: *mut PIX,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeOrientDecision(
        upconf: l_float32,
        leftconf: l_float32,
        minupconf: l_float32,
        minratio: l_float32,
        porient: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUpDownDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        npixels: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMirrorDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixCreate(width: l_int32, height: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCreateTemplate(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixClone(fpix: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCopy(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixDestroy(pfpix: *mut *mut FPIX);
}
extern "C" {
    pub fn fpixGetDimensions(fpix: *mut FPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetDimensions(fpix: *mut FPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetWpl(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixSetWpl(fpix: *mut FPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetRefcount(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixChangeRefcount(fpix: *mut FPIX, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetResolution(fpix: *mut FPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetResolution(fpix: *mut FPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixCopyResolution(fpixd: *mut FPIX, fpixs: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixGetData(fpix: *mut FPIX) -> *mut l_float32;
}
extern "C" {
    pub fn fpixSetData(fpix: *mut FPIX, data: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixGetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixSetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixaCreate(n: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaCopy(fpixa: *mut FPIXA, copyflag: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaDestroy(pfpixa: *mut *mut FPIXA);
}
extern "C" {
    pub fn fpixaAddFPix(fpixa: *mut FPIXA, fpix: *mut FPIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixaGetCount(fpixa: *mut FPIXA) -> l_int32;
}
extern "C" {
    pub fn fpixaChangeRefcount(fpixa: *mut FPIXA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixaGetFPix(fpixa: *mut FPIXA, index: l_int32, accesstype: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixaGetFPixDimensions(
        fpixa: *mut FPIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaGetData(fpixa: *mut FPIXA, index: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn fpixaGetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaSetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        val: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixCreate(width: l_int32, height: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCreateTemplate(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixClone(dpix: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCopy(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixDestroy(pdpix: *mut *mut DPIX);
}
extern "C" {
    pub fn dpixGetDimensions(dpix: *mut DPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetDimensions(dpix: *mut DPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetWpl(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixSetWpl(dpix: *mut DPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetRefcount(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixChangeRefcount(dpix: *mut DPIX, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetResolution(dpix: *mut DPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetResolution(dpix: *mut DPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixCopyResolution(dpixd: *mut DPIX, dpixs: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixGetData(dpix: *mut DPIX) -> *mut l_float64;
}
extern "C" {
    pub fn dpixSetData(dpix: *mut DPIX, data: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixGetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixSetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixRead(filename: *const ::std::os::raw::c_char) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadStream(fp: *mut FILE) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadMem(data: *const l_uint8, size: size_t) -> *mut FPIX;
}
extern "C" {
    pub fn fpixWrite(filename: *const ::std::os::raw::c_char, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteStream(fp: *mut FILE, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixEndianByteSwap(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn dpixRead(filename: *const ::std::os::raw::c_char) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadStream(fp: *mut FILE) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadMem(data: *const l_uint8, size: size_t) -> *mut DPIX;
}
extern "C" {
    pub fn dpixWrite(filename: *const ::std::os::raw::c_char, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteStream(fp: *mut FILE, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixEndianByteSwap(dpixd: *mut DPIX, dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn fpixPrintStream(fp: *mut FILE, fpix: *mut FPIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertToFPix(pixs: *mut PIX, ncomps: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvertToDPix(pixs: *mut PIX, ncomps: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixConvertToPix(
        fpixs: *mut FPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixDisplayMaxDynamicRange(fpixs: *mut FPIX) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvertToDPix(fpix: *mut FPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixConvertToPix(
        dpixs: *mut DPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn dpixConvertToFPix(dpix: *mut DPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixGetMin(
        fpix: *mut FPIX,
        pminval: *mut l_float32,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixGetMax(
        fpix: *mut FPIX,
        pmaxval: *mut l_float32,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMin(
        dpix: *mut DPIX,
        pminval: *mut l_float64,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMax(
        dpix: *mut DPIX,
        pmaxval: *mut l_float64,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixScaleByInteger(fpixs: *mut FPIX, factor: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn dpixScaleByInteger(dpixs: *mut DPIX, factor: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixLinearCombination(
        fpixd: *mut FPIX,
        fpixs1: *mut FPIX,
        fpixs2: *mut FPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMultConstant(fpix: *mut FPIX, addc: l_float32, multc: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixLinearCombination(
        dpixd: *mut DPIX,
        dpixs1: *mut DPIX,
        dpixs2: *mut DPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut DPIX;
}
extern "C" {
    pub fn dpixAddMultConstant(dpix: *mut DPIX, addc: l_float64, multc: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixSetAllArbitrary(fpix: *mut FPIX, inval: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixSetAllArbitrary(dpix: *mut DPIX, inval: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixAddBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRemoveBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMirroredBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddContinuedBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddSlopeBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRasterop(
        fpixd: *mut FPIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        fpixs: *mut FPIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixRotateOrth(fpixs: *mut FPIX, quads: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate180(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate90(fpixs: *mut FPIX, direction: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipLR(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipTB(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffinePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffine(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjectivePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjective(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn linearInterpolatePixelFloat(
        datas: *mut l_float32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        inval: l_float32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixThresholdToPix(fpix: *mut FPIX, thresh: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixComponentFunction(
        pix: *mut PIX,
        rnum: l_float32,
        gnum: l_float32,
        bnum: l_float32,
        rdenom: l_float32,
        gdenom: l_float32,
        bdenom: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixReadStreamGif(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemGif(cdata: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamGif(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemGif(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn gplotCreate(
        rootname: *const ::std::os::raw::c_char,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotDestroy(pgplot: *mut *mut GPLOT);
}
extern "C" {
    pub fn gplotAddPlot(
        gplot: *mut GPLOT,
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        plotlabel: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSetScaling(gplot: *mut GPLOT, scaling: l_int32) -> l_ok;
}
extern "C" {
    pub fn gplotMakeOutputPix(gplot: *mut GPLOT) -> *mut PIX;
}
extern "C" {
    pub fn gplotMakeOutput(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenCommandFile(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenDataFiles(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotSimple1(
        na: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimple2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimpleN(
        naa: *mut NUMAA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimplePix1(na: *mut NUMA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        title: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePixN(naa: *mut NUMAA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimpleXY1(
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXY2(
        nax: *mut NUMA,
        nay1: *mut NUMA,
        nay2: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXYN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotGeneralPix1(
        na: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPixN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotRead(filename: *const ::std::os::raw::c_char) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotWrite(filename: *const ::std::os::raw::c_char, gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn generatePtaLine(x1: l_int32, y1: l_int32, x2: l_int32, y2: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaWideLine(
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBox(box_: *mut BOX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBoxa(boxa: *mut BOXA, width: l_int32, removedups: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBox(
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaaBoxa(boxa: *mut BOXA) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaPolyline(
        ptas: *mut PTA,
        width: l_int32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaGrid(
        w: l_int32,
        h: l_int32,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn convertPtaLineTo4cc(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledCircle(radius: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledSquare(side: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaLineFromPt(
        x: l_int32,
        y: l_int32,
        length: l_float64,
        radang: l_float64,
    ) -> *mut PTA;
}
extern "C" {
    pub fn locatePtRadially(
        xr: l_int32,
        yr: l_int32,
        dist: l_float64,
        radang: l_float64,
        px: *mut l_float64,
        py: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPlotFromNuma(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNuma(
        na: *mut NUMA,
        size: l_int32,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPlotFromNumaGen(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNumaGen(
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPta(pix: *mut PIX, pta: *mut PTA, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaArb(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaBlend(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineArb(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineBlend(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBox(pix: *mut PIX, box_: *mut BOX, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxa(pix: *mut PIX, boxa: *mut BOXA, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBox(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashMaskArb(
        pix: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxa(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolyline(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        op: l_int32,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineArb(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineBlend(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderGridArb(
        pix: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderRandomCmapPtaa(
        pix: *mut PIX,
        ptaa: *mut PTAA,
        polyflag: l_int32,
        width: l_int32,
        closeflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderPolygon(
        ptas: *mut PTA,
        width: l_int32,
        pxmin: *mut l_int32,
        pymin: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFillPolygon(pixs: *mut PIX, pta: *mut PTA, xmin: l_int32, ymin: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderContours(
        pixs: *mut PIX,
        startval: l_int32,
        incr: l_int32,
        outdepth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixAutoRenderContours(fpix: *mut FPIX, ncontours: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn fpixRenderContours(fpixs: *mut FPIX, incr: l_float32, proxim: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixGeneratePtaBoundary(pixs: *mut PIX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn pixErodeGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinary(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinarySpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ditherToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        bufs1: *mut l_uint32,
        bufs2: *mut l_uint32,
        lowerclip: l_int32,
        upperclip: l_int32,
        lastlineflag: l_int32,
    );
}
extern "C" {
    pub fn pixThresholdToBinary(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn thresholdToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        lines: *mut l_uint32,
        d: l_int32,
        thresh: l_int32,
    );
}
extern "C" {
    pub fn pixVarThresholdToBinary(pixs: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinary(pixs: *mut PIX, pixm: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinaryGen(
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByValue(pixs: *mut PIX, val: l_int32, usecmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByBand(
        pixs: *mut PIX,
        lower: l_int32,
        upper: l_int32,
        inband: l_int32,
        usecmap: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bpp(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bppSpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo2bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo4bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdOn8bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdGrayArb(
        pixs: *mut PIX,
        edgevals: *const ::std::os::raw::c_char,
        outdepth: l_int32,
        use_average: l_int32,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeGrayQuantIndexTable(nlevels: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn makeGrayQuantTableArb(
        na: *mut NUMA,
        outdepth: l_int32,
        ptab: *mut *mut l_int32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenerateMaskByBand32(
        pixs: *mut PIX,
        refval: l_uint32,
        delm: l_int32,
        delp: l_int32,
        fractm: l_float32,
        fractp: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByDiscr32(
        pixs: *mut PIX,
        refval1: l_uint32,
        refval2: l_uint32,
        distflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromHisto(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        minfract: l_float32,
        maxsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromCmap(pixs: *mut PIX, cmap: *mut PIXCMAP, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn l_hmapCreate(ninit: l_int32, maxocc: l_int32) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_hmapDestroy(phmap: *mut *mut L_HASHMAP);
}
extern "C" {
    pub fn l_hmapLookup(
        hmap: *mut L_HASHMAP,
        key: l_uint64,
        val: l_uint64,
        op: l_int32,
    ) -> *mut L_HASHITEM;
}
extern "C" {
    pub fn l_hmapRehash(hmap: *mut L_HASHMAP) -> l_ok;
}
extern "C" {
    pub fn lheapCreate(n: l_int32, direction: l_int32) -> *mut L_HEAP;
}
extern "C" {
    pub fn lheapDestroy(plh: *mut *mut L_HEAP, freeflag: l_int32);
}
extern "C" {
    pub fn lheapAdd(lh: *mut L_HEAP, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lheapRemove(lh: *mut L_HEAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapGetCount(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapGetElement(lh: *mut L_HEAP, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapSort(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapSortStrictOrder(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapPrint(fp: *mut FILE, lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn jbRankHausInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        size: l_int32,
        rank: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInitWithoutComponents(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbAddPages(classer: *mut JBCLASSER, safiles: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn jbAddPage(classer: *mut JBCLASSER, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn jbAddPageComponents(
        classer: *mut JBCLASSER,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbClassifyRankHaus(classer: *mut JBCLASSER, boxa: *mut BOXA, pixas: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRankHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        area1: l_int32,
        area3: l_int32,
        rank: l_float32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbClassifyCorrelation(
        classer: *mut JBCLASSER,
        boxa: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbGetComponents(
        pixs: *mut PIX,
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordMaskByDilation(
        pixs: *mut PIX,
        ppixm: *mut *mut PIX,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordBoxesByDilation(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxa: *mut *mut BOXA,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbAccumulateComposites(
        pixaa: *mut PIXAA,
        pna: *mut *mut NUMA,
        pptat: *mut *mut PTA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn jbTemplatesFromComposites(pixac: *mut PIXA, na: *mut NUMA) -> *mut PIXA;
}
extern "C" {
    pub fn jbClasserCreate(method: l_int32, components: l_int32) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbClasserDestroy(pclasser: *mut *mut JBCLASSER);
}
extern "C" {
    pub fn jbDataSave(classer: *mut JBCLASSER) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataDestroy(pdata: *mut *mut JBDATA);
}
extern "C" {
    pub fn jbDataWrite(rootout: *const ::std::os::raw::c_char, jbdata: *mut JBDATA) -> l_ok;
}
extern "C" {
    pub fn jbDataRead(rootname: *const ::std::os::raw::c_char) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataRender(data: *mut JBDATA, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn jbGetULCorners(classer: *mut JBCLASSER, pixs: *mut PIX, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn jbGetLLCorners(classer: *mut JBCLASSER) -> l_ok;
}
extern "C" {
    pub fn readHeaderJp2k(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJp2k(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemJp2k(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJp2kResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixReadJp2k(
        filename: *const ::std::os::raw::c_char,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJp2k(
        fp: *mut FILE,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteJp2k(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJp2k(
        fp: *mut FILE,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        codec: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJp2k(
        data: *const l_uint8,
        size: size_t,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemJp2k(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadJpeg(
        filename: *const ::std::os::raw::c_char,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJpeg(
        fp: *mut FILE,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderJpeg(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJpeg(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJpegResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fgetJpegComment(fp: *mut FILE, pcomment: *mut *mut l_uint8) -> l_int32;
}
extern "C" {
    pub fn pixWriteJpeg(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJpeg(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJpeg(
        data: *const l_uint8,
        size: size_t,
        cmflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemJpeg(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readResolutionMemJpeg(
        data: *const l_uint8,
        size: size_t,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemJpeg(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetChromaSampling(pix: *mut PIX, sampling: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelCreate(height: l_int32, width: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDestroy(pkel: *mut *mut L_KERNEL);
}
extern "C" {
    pub fn kernelCopy(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelGetElement(
        kel: *mut L_KERNEL,
        row: l_int32,
        col: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetElement(kel: *mut L_KERNEL, row: l_int32, col: l_int32, val: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn kernelGetParameters(
        kel: *mut L_KERNEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetOrigin(kel: *mut L_KERNEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelGetSum(kel: *mut L_KERNEL, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelGetMinMax(kel: *mut L_KERNEL, pmin: *mut l_float32, pmax: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelNormalize(kels: *mut L_KERNEL, normsum: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelInvert(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn create2dFloatArray(sy: l_int32, sx: l_int32) -> *mut *mut l_float32;
}
extern "C" {
    pub fn kernelRead(fname: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelReadStream(fp: *mut FILE) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelWrite(fname: *const ::std::os::raw::c_char, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelWriteStream(fp: *mut FILE, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelCreateFromString(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        kdata: *const ::std::os::raw::c_char,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromPix(pix: *mut PIX, cy: l_int32, cx: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDisplayInPix(kel: *mut L_KERNEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn parseStringForNumbers(
        str_: *const ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn makeFlatKernel(
        height: l_int32,
        width: l_int32,
        cy: l_int32,
        cx: l_int32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernelSep(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
        pkelx: *mut *mut L_KERNEL,
        pkely: *mut *mut L_KERNEL,
    ) -> l_ok;
}
extern "C" {
    pub fn makeDoGKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        ratio: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn getImagelibVersions() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn listDestroy(phead: *mut *mut DLLIST);
}
extern "C" {
    pub fn listAddToHead(phead: *mut *mut DLLIST, data: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn listAddToTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertBefore(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertAfter(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listRemoveElement(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromHead(phead: *mut *mut DLLIST) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listFindElement(head: *mut DLLIST, data: *mut ::std::os::raw::c_void) -> *mut DLLIST;
}
extern "C" {
    pub fn listFindTail(head: *mut DLLIST) -> *mut DLLIST;
}
extern "C" {
    pub fn listGetCount(head: *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn listReverse(phead: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn listJoin(phead1: *mut *mut DLLIST, phead2: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn l_amapCreate(keytype: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn l_amapFind(m: *mut L_AMAP, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_amapInsert(m: *mut L_AMAP, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_amapDelete(m: *mut L_AMAP, key: RB_TYPE);
}
extern "C" {
    pub fn l_amapDestroy(pm: *mut *mut L_AMAP);
}
extern "C" {
    pub fn l_amapGetFirst(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetNext(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetLast(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetPrev(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapSize(m: *mut L_AMAP) -> l_int32;
}
extern "C" {
    pub fn l_asetCreate(keytype: l_int32) -> *mut L_ASET;
}
extern "C" {
    pub fn l_asetFind(s: *mut L_ASET, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_asetInsert(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDelete(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDestroy(ps: *mut *mut L_ASET);
}
extern "C" {
    pub fn l_asetGetFirst(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetNext(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetLast(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetPrev(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetSize(s: *mut L_ASET) -> l_int32;
}
extern "C" {
    pub fn generateBinaryMaze(
        w: l_int32,
        h: l_int32,
        xi: l_int32,
        yi: l_int32,
        wallps: l_float32,
        ranis: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSearchBinaryMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixSearchGrayMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDilate(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixErode(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHMT(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpen(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixClose(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafe(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrick(pixd: *mut PIX, pixs: *mut PIX, hsize: l_int32, vsize: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selectComposableSels(
        size: l_int32,
        direction: l_int32,
        psel1: *mut *mut SEL,
        psel2: *mut *mut SEL,
    ) -> l_int32;
}
extern "C" {
    pub fn selectComposableSizes(
        size: l_int32,
        pfactor1: *mut l_int32,
        pfactor2: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn resetMorphBoundaryCondition(bc: l_int32);
}
extern "C" {
    pub fn getMorphBorderPixelColor(type_: l_int32, depth: l_int32) -> l_uint32;
}
extern "C" {
    pub fn pixExtractBoundary(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceByComponent(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByComponent(
        pixas: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixMorphSequenceByRegion(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByRegion(
        pixs: *mut PIX,
        pixam: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixUnionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixIntersectionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectiveConnCompFill(
        pixs: *mut PIX,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        dsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        color: l_uint32,
        scale: l_float32,
        nlevels: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtendByMorph(
        pixas: *mut PIXA,
        type_: l_int32,
        niters: l_int32,
        sel: *mut SEL,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaExtendByScaling(
        pixas: *mut PIXA,
        nasc: *mut NUMA,
        type_: l_int32,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSeedfillMorph(
        pixs: *mut PIX,
        pixm: *mut PIX,
        maxiters: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunHistogramMorph(
        pixs: *mut PIX,
        runtype: l_int32,
        direction: l_int32,
        maxsize: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixTophat(pixs: *mut PIX, hsize: l_int32, vsize: l_int32, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixHDome(pixs: *mut PIX, height: l_int32, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFastTophat(
        pixs: *mut PIX,
        xsize: l_int32,
        ysize: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphGradient(
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
        smoothing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaCentroids(pixa: *mut PIXA) -> *mut PTA;
}
extern "C" {
    pub fn pixCentroid(
        pix: *mut PIX,
        centtab: *mut l_int32,
        sumtab: *mut l_int32,
        pxave: *mut l_float32,
        pyave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getExtendedCompositeParameters(
        size: l_int32,
        pn: *mut l_int32,
        pextra: *mut l_int32,
        pactualsize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn morphSequenceVerify(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn pixGrayMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaCreate(n: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromFArray(
        farray: *mut l_float32,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromString(str_: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaDestroy(pna: *mut *mut NUMA);
}
extern "C" {
    pub fn numaCopy(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaClone(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaEmpty(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaAddNumber(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaInsertNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaRemoveNumber(na: *mut NUMA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaReplaceNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetCount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSetCount(na: *mut NUMA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetFValue(na: *mut NUMA, index: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIValue(na: *mut NUMA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaSetValue(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaShiftValue(na: *mut NUMA, index: l_int32, diff: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIArray(na: *mut NUMA) -> *mut l_int32;
}
extern "C" {
    pub fn numaGetFArray(na: *mut NUMA, copyflag: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn numaGetRefcount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaChangeRefcount(na: *mut NUMA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetParameters(na: *mut NUMA, pstartx: *mut l_float32, pdelx: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn numaSetParameters(na: *mut NUMA, startx: l_float32, delx: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaCopyParameters(nad: *mut NUMA, nas: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaConvertToSarray(
        na: *mut NUMA,
        size1: l_int32,
        size2: l_int32,
        addzeros: l_int32,
        type_: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn numaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadStream(fp: *mut FILE) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadMem(data: *const l_uint8, size: size_t) -> *mut NUMA;
}
extern "C" {
    pub fn numaWriteDebug(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWrite(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStream(fp: *mut FILE, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStderr(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaCreate(n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCreateFull(nptr: l_int32, n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaTruncate(naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaDestroy(pnaa: *mut *mut NUMAA);
}
extern "C" {
    pub fn numaaAddNuma(naa: *mut NUMAA, na: *mut NUMA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaGetCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumaCount(naa: *mut NUMAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumberCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetPtrArray(naa: *mut NUMAA) -> *mut *mut NUMA;
}
extern "C" {
    pub fn numaaGetNuma(naa: *mut NUMAA, index: l_int32, accessflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaaReplaceNuma(naa: *mut NUMAA, index: l_int32, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaGetValue(
        naa: *mut NUMAA,
        i: l_int32,
        j: l_int32,
        pfval: *mut l_float32,
        pival: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaaAddNumber(naa: *mut NUMAA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadStream(fp: *mut FILE) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadMem(data: *const l_uint8, size: size_t) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaWrite(filename: *const ::std::os::raw::c_char, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteStream(fp: *mut FILE, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaArithOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaLogicalOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaInvert(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimilar(
        na1: *mut NUMA,
        na2: *mut NUMA,
        maxdiff: l_float32,
        psimilar: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaAddToNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMin(na: *mut NUMA, pminval: *mut l_float32, piminloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMax(na: *mut NUMA, pmaxval: *mut l_float32, pimaxloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetSum(na: *mut NUMA, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetPartialSums(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSumOnInterval(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHasOnlyIntegers(na: *mut NUMA, pallints: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMean(na: *mut NUMA, pave: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanAbsval(na: *mut NUMA, paveabs: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaSubsample(nas: *mut NUMA, subfactor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeDelta(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeSequence(startval: l_float32, increment: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeConstant(val: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeAbsval(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        val: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSpecifiedBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRemoveBorder(nas: *mut NUMA, left: l_int32, right: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCountNonzeroRuns(na: *mut NUMA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetNonzeroRange(
        na: *mut NUMA,
        eps: l_float32,
        pfirst: *mut l_int32,
        plast: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetCountRelativeToZero(na: *mut NUMA, type_: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaClipToInterval(nas: *mut NUMA, first: l_int32, last: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeThresholdIndicator(
        nas: *mut NUMA,
        thresh: l_float32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaUniformSampling(nas: *mut NUMA, nsamp: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaReverse(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaLowPassIntervals(nas: *mut NUMA, thresh: l_float32, maxn: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaThresholdEdges(
        nas: *mut NUMA,
        thresh1: l_float32,
        thresh2: l_float32,
        maxn: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSpanValues(
        na: *mut NUMA,
        span: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetEdgeValues(
        na: *mut NUMA,
        edge: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
        psign: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateEqxVal(
        startx: l_float32,
        deltax: l_float32,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxVal(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateEqxInterval(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFitMax(
        na: *mut NUMA,
        pmaxval: *mut l_float32,
        naloc: *mut NUMA,
        pmaxloc: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDifferentiateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaIntegrateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortGeneral(
        na: *mut NUMA,
        pnasort: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        pnainvert: *mut *mut NUMA,
        sortorder: l_int32,
        sorttype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortIndexAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaChooseSortType(nas: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSort(naout: *mut NUMA, nain: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaBinSort(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSortIndex(na: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetBinSortIndex(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortByIndex(nas: *mut NUMA, naindex: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaIsSorted(nas: *mut NUMA, sortorder: l_int32, psorted: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaSortPair(
        nax: *mut NUMA,
        nay: *mut NUMA,
        sortorder: l_int32,
        pnasx: *mut *mut NUMA,
        pnasy: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInvertMap(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSorted(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaFindSortedLoc(na: *mut NUMA, val: l_float32, pindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaPseudorandomSequence(size: l_int32, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaRandomPermutation(nas: *mut NUMA, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetRankValue(
        na: *mut NUMA,
        fract: l_float32,
        nasort: *mut NUMA,
        usebins: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMedian(na: *mut NUMA, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetBinnedMedian(na: *mut NUMA, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanDevFromMedian(na: *mut NUMA, med: l_float32, pdev: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMedianDevFromMedian(
        na: *mut NUMA,
        pmed: *mut l_float32,
        pdev: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMode(na: *mut NUMA, pval: *mut l_float32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaJoin(nad: *mut NUMA, nas: *mut NUMA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaJoin(naad: *mut NUMAA, naas: *mut NUMAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaFlattenToNuma(naa: *mut NUMAA) -> *mut NUMA;
}
extern "C" {
    pub fn numaErode(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaDilate(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaOpen(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaClose(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaTransform(nas: *mut NUMA, shift: l_float32, scale: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimpleStats(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        pmean: *mut l_float32,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedStats(
        nas: *mut NUMA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMean(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedMeanSquare(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedVariance(
        nam: *mut NUMA,
        nams: *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMedian(nas: *mut NUMA, halfwin: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToInt(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pbinsize: *mut l_int32,
        pbinstart: *mut l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramAuto(na: *mut NUMA, maxbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramClipped(
        na: *mut NUMA,
        binsize: l_float32,
        maxsize: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRebinHistogram(nas: *mut NUMA, newsize: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaNormalizeHistogram(nas: *mut NUMA, tsum: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetStatsUsingHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pmin: *mut l_float32,
        pmax: *mut l_float32,
        pmean: *mut l_float32,
        pvariance: *mut l_float32,
        pmedian: *mut l_float32,
        rank: l_float32,
        prval: *mut l_float32,
        phisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStats(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStatsOnInterval(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        ifirst: l_int32,
        ilast: l_int32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaMakeRankFromHistogram(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetRankFromVal(
        na: *mut NUMA,
        rval: l_float32,
        prank: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetValFromRank(
        na: *mut NUMA,
        rank: l_float32,
        prval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeSortedInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeHistoInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
        pnarank: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetRankBinValues(na: *mut NUMA, nbins: l_int32, pnam: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaGetUniformBinSizes(ntotal: l_int32, nbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSplitDistribution(
        na: *mut NUMA,
        scorefract: l_float32,
        psplitindex: *mut l_int32,
        pave1: *mut l_float32,
        pave2: *mut l_float32,
        pnum1: *mut l_float32,
        pnum2: *mut l_float32,
        pnascore: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn grayHistogramsToEMD(naa1: *mut NUMAA, naa2: *mut NUMAA, pnad: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaEarthMoverDistance(na1: *mut NUMA, na2: *mut NUMA, pdist: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn grayInterHistogramStats(
        naa: *mut NUMAA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFindPeaks(
        nas: *mut NUMA,
        nmax: l_int32,
        fract1: l_float32,
        fract2: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindExtrema(nas: *mut NUMA, delta: l_float32, pnav: *mut *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindLocForThreshold(
        na: *mut NUMA,
        skip: l_int32,
        pthresh: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCountReversals(
        nas: *mut NUMA,
        minreversal: l_float32,
        pnr: *mut l_int32,
        prd: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSelectCrossingThreshold(
        nax: *mut NUMA,
        nay: *mut NUMA,
        estthresh: l_float32,
        pbestthresh: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCrossingsByThreshold(nax: *mut NUMA, nay: *mut NUMA, thresh: l_float32)
        -> *mut NUMA;
}
extern "C" {
    pub fn numaCrossingsByPeaks(nax: *mut NUMA, nay: *mut NUMA, delta: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaEvalBestHaarParameters(
        nas: *mut NUMA,
        relweight: l_float32,
        nwidth: l_int32,
        nshift: l_int32,
        minwidth: l_float32,
        maxwidth: l_float32,
        pbestwidth: *mut l_float32,
        pbestshift: *mut l_float32,
        pbestscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaEvalHaarSum(
        nas: *mut NUMA,
        width: l_float32,
        shift: l_float32,
        relweight: l_float32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn genConstrainedNumaInRange(
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRegionsBinary(
        pixs: *mut PIX,
        ppixhm: *mut *mut PIX,
        ppixtm: *mut *mut PIX,
        ppixtb: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextlineMask(
        pixs: *mut PIX,
        ppixvws: *mut *mut PIX,
        ptlfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextblockMask(pixs: *mut PIX, pixvws: *mut PIX, pixadb: *mut PIXA) -> *mut PIX;
}
extern "C" {
    pub fn pixFindPageForeground(
        pixs: *mut PIX,
        threshold: l_int32,
        mindist: l_int32,
        erasedist: l_int32,
        showmorph: l_int32,
        pixac: *mut PIXAC,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSplitIntoCharacters(
        pixs: *mut PIX,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdebug: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitComponentWithProfile(
        pixs: *mut PIX,
        delta: l_int32,
        mindel: l_int32,
        ppixdebug: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixExtractTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        minw: l_int32,
        minh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixExtractRawTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixCountTextColumns(
        pixs: *mut PIX,
        deltafract: l_float32,
        peakfract: l_float32,
        clipfract: l_float32,
        pncols: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfText(
        pixs: *mut PIX,
        box_: *mut BOX,
        pistext: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindThreshFgExtent(
        pixs: *mut PIX,
        thresh: l_int32,
        ptop: *mut l_int32,
        pbot: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfTable(
        pixs: *mut PIX,
        box_: *mut BOX,
        orient: l_int32,
        pscore: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPrepare1bpp(
        pixs: *mut PIX,
        box_: *mut BOX,
        cropfract: l_float32,
        outres: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEstimateBackground(
        pixs: *mut PIX,
        darkthresh: l_int32,
        edgecrop: l_float32,
        pbg: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargeRectangles(
        pixs: *mut PIX,
        polarity: l_int32,
        nrect: l_int32,
        pboxa: *mut *mut BOXA,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargestRectangle(
        pixs: *mut PIX,
        polarity: l_int32,
        pbox: *mut *mut BOX,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleInCC(
        pixs: *mut PIX,
        boxs: *mut BOX,
        fract: l_float32,
        dir: l_int32,
        select: l_int32,
        debug: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixAutoPhotoinvert(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixm: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetSelectCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayRegionsCmap(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn addColorizedGrayToCmap(
        cmap: *mut PIXCMAP,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetSelectMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn parseForProtos(
        filein: *const ::std::os::raw::c_char,
        prestring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn partifyFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn partifyPixac(
        pixac: *mut PIXAC,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetWhiteblocks(
        boxas: *mut BOXA,
        box_: *mut BOX,
        sortflag: l_int32,
        maxboxes: l_int32,
        maxoverlap: l_float32,
        maxperim: l_int32,
        fract: l_float32,
        maxpops: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPruneSortedOnOverlap(boxas: *mut BOXA, maxoverlap: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn convertFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdf(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdfData(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn selectDefaultPdfEncoding(pix: *mut PIX, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdf(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdfData(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledToPdfData(
        fname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdf(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdfData(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdf(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdf(
        imdata: *mut l_uint8,
        size: size_t,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfData(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdfData(
        imdata: *mut l_uint8,
        size: size_t,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdf(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPdf(
        fp: *mut FILE,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPdf(
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        baa: *mut BOXAA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertNumberedMasksToBoxaa(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn convertToPdfSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfDataSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfDataSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn concatenatePdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdf(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdf(pa: *mut L_PTRA, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn concatenatePdfToData(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdfToData(
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfData(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdfToData(
        pa_data: *mut L_PTRA,
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPdf(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIDataForPdf(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIData(
        fname: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateDataPdf(
        fname: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegDataMem(
        data: *mut l_uint8,
        nbytes: size_t,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateG4Data(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn pixGenerateCIData(
        pixs: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn cidConvertToPdfData(
        cid: *mut L_COMP_DATA,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn l_CIDataDestroy(pcid: *mut *mut L_COMP_DATA);
}
extern "C" {
    pub fn l_pdfSetG4ImageMask(flag: l_int32);
}
extern "C" {
    pub fn l_pdfSetDateAndVersion(flag: l_int32);
}
extern "C" {
    pub fn setPixMemoryManager(allocator: alloc_fn, deallocator: dealloc_fn);
}
extern "C" {
    pub fn pixCreate(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateNoInit(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplate(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplateNoInit(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateWithCmap(
        width: l_int32,
        height: l_int32,
        depth: l_int32,
        initcolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateHeader(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixClone(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDestroy(ppix: *mut *mut PIX);
}
extern "C" {
    pub fn pixCopy(pixd: *mut PIX, pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeImageData(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixCopyColormap(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixTransferAllData(
        pixd: *mut PIX,
        ppixs: *mut *mut PIX,
        copytext: l_int32,
        copyformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSwapAndDestroy(ppixd: *mut *mut PIX, ppixs: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWidth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWidth(pix: *mut PIX, width: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetHeight(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetHeight(pix: *mut PIX, height: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDepth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetDepth(pix: *mut PIX, depth: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDimensions(
        pix: *const PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetDimensions(pix: *mut PIX, w: l_int32, h: l_int32, d: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyDimensions(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetSpp(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpp(pix: *mut PIX, spp: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopySpp(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWpl(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWpl(pix: *mut PIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRefcount(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixChangeRefcount(pix: *mut PIX, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetXRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetXRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetYRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetYRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetResolution(pix: *const PIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetResolution(pix: *mut PIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyResolution(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixScaleResolution(pix: *mut PIX, xscale: l_float32, yscale: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixGetInputFormat(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetInputFormat(pix: *mut PIX, informat: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyInputFormat(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpecial(pix: *mut PIX, special: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetText(pix: *mut PIX) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixSetText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixAddText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixCopyText(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetTextCompNew(pix: *mut PIX, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn pixSetTextCompNew(pix: *mut PIX, data: *const l_uint8, size: size_t) -> l_ok;
}
extern "C" {
    pub fn pixGetColormap(pix: *mut PIX) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixSetColormap(pix: *mut PIX, colormap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixDestroyColormap(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetData(pix: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixExtractData(pixs: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixFreeData(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetLinePtrs(pix: *mut PIX, psize: *mut l_int32) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixSizesEqual(pix1: *const PIX, pix2: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixMaxAspectRatio(pixs: *mut PIX, pratio: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixPrintStreamInfo(
        fp: *mut FILE,
        pix: *const PIX,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixel(pix: *mut PIX, x: l_int32, y: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetPixel(pix: *mut PIX, x: l_int32, y: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetCmapPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRandomPixel(
        pix: *mut PIX,
        pval: *mut l_uint32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClearPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFlipPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn setPixelLow(line: *mut l_uint32, x: l_int32, depth: l_int32, val: l_uint32);
}
extern "C" {
    pub fn pixGetBlackOrWhiteVal(pixs: *mut PIX, op: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixClearAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAllGray(pix: *mut PIX, grayval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetAllArbitrary(pix: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetBlackOrWhite(pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetComponentArbitrary(pix: *mut PIX, comp: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClearInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRectArbitrary(pix: *mut PIX, box_: *mut BOX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixBlendInRect(pixs: *mut PIX, box_: *mut BOX, val: l_uint32, fract: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBits(pix: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBitsBand(pix: *mut PIX, by: l_int32, bh: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetOrClearBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderVal(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderRingVal(pixs: *mut PIX, dist: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyBorder(
        pixd: *mut PIX,
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorder(pixs: *mut PIX, npix: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBlackOrWhiteBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorder(pixs: *mut PIX, npix: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRepeatedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMixedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddContinuedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixShiftAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        shiftx: l_float32,
        shifty: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayLayersRGBA(pixs: *mut PIX, val: l_uint32, maxw: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateRGBImage(pixr: *mut PIX, pixg: *mut PIX, pixb: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBComponent(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBComponentCmap(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCopyRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn composeRGBPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn composeRGBAPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn extractRGBValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractRGBAValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractMinMaxComponent(pixel: l_uint32, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBLine(
        pixs: *mut PIX,
        row: l_int32,
        bufr: *mut l_uint8,
        bufg: *mut l_uint8,
        bufb: *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn setLineDataVal(line: *mut l_uint32, j: l_int32, d: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixEndianByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn lineEndianByteSwap(datad: *mut l_uint32, datas: *mut l_uint32, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixEndianTwoByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianTwoByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRasterData(pixs: *mut PIX, pdata: *mut *mut l_uint8, pnbytes: *mut size_t)
        -> l_ok;
}
extern "C" {
    pub fn pixInferResolution(pix: *mut PIX, longside: l_float32, pres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixAlphaIsOpaque(pix: *mut PIX, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetupByteProcessing(
        pix: *mut PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut *mut l_uint8;
}
extern "C" {
    pub fn pixCleanupByteProcessing(pix: *mut PIX, lineptrs: *mut *mut l_uint8) -> l_ok;
}
extern "C" {
    pub fn l_setAlphaMaskBorder(val1: l_float32, val2: l_float32);
}
extern "C" {
    pub fn pixSetMasked(pixd: *mut PIX, pixm: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedGeneral(
        pixd: *mut PIX,
        pixm: *mut PIX,
        val: l_uint32,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCombineMasked(pixd: *mut PIX, pixs: *mut PIX, pixm: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixCombineMaskedGeneral(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPaintThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyWithBoxa(pixs: *mut PIX, boxa: *mut BOXA, background: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintSelfThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        searchdir: l_int32,
        mindist: l_int32,
        tilesize: l_int32,
        ntiles: l_int32,
        distblend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeMaskFromVal(pixs: *mut PIX, val: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeMaskFromLUT(pixs: *mut PIX, tab: *mut l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeArbMaskFromRGB(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetUnderTransparency(pixs: *mut PIX, val: l_uint32, debug: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeAlphaFromMask(pixs: *mut PIX, dist: l_int32, pbox: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetColorNearMaskBoundary(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pval: *mut l_uint32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplaySelectedPixels(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sel: *mut SEL,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInvert(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixOr(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAnd(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixXor(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtract(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixZero(pix: *mut PIX, pempty: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixForegroundFraction(pix: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaCountPixels(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixels(pixs: *mut PIX, pcount: *mut l_int32, tab8: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountPixelsInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByRow(pix: *mut PIX, tab8: *mut l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByColumn(pix: *mut PIX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsInRow(
        pix: *mut PIX,
        row: l_int32,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMomentByColumn(pix: *mut PIX, order: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixThresholdPixelSum(
        pix: *mut PIX,
        thresh: l_int32,
        pabove: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePixelSumTab8() -> *mut l_int32;
}
extern "C" {
    pub fn makePixelCentroidTab8() -> *mut l_int32;
}
extern "C" {
    pub fn pixAverageByRow(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageByColumn(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageInRect(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        minval: l_int32,
        maxval: l_int32,
        subsamp: l_int32,
        pave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAverageInRectRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        subsamp: l_int32,
        pave: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceInRect(pix: *mut PIX, box_: *mut BOX, prootvar: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffInRect(
        pix: *mut PIX,
        box_: *mut BOX,
        dir: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffOnLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountArbInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        val: l_int32,
        factor: l_int32,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirroredTiling(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindRepCloseTile(
        pixs: *mut PIX,
        box_: *mut BOX,
        searchdir: l_int32,
        mindist: l_int32,
        tsize: l_int32,
        ntiles: l_int32,
        pboxtile: *mut *mut BOX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetGrayHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramTiled(
        pixs: *mut PIX,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixGetColorHistogram(
        pixs: *mut PIX,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColorHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetCmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountRGBColorsByHash(pixs: *mut PIX, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountRGBColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetColorAmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn amapGetCountForColor(amap: *mut L_AMAP, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixGetRankValue(
        pixs: *mut PIX,
        factor: l_int32,
        rank: l_float32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        pval: *mut l_float32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelAverage(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelStats(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiledRGB(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiled(pixs: *mut PIX, sx: l_int32, sy: l_int32, type_: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixRowStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColumnStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRangeValues(
        pixs: *mut PIX,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetExtremeValue(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        pgrayval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxValueInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pmaxval: *mut l_uint32,
        pxmax: *mut l_int32,
        pymax: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxColorIndex(pixs: *mut PIX, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedComponentRange(
        pixs: *mut PIX,
        nbins: l_int32,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pcarray: *mut *mut l_uint32,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankColorArray(
        pixs: *mut PIX,
        nbins: l_int32,
        type_: l_int32,
        factor: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedColor(
        pixs: *mut PIX,
        pixg: *mut PIX,
        factor: l_int32,
        nbins: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayColorArray(
        carray: *mut l_uint32,
        ncolors: l_int32,
        side: l_int32,
        ncols: l_int32,
        fontsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRankBinByStrip(
        pixs: *mut PIX,
        direction: l_int32,
        size: l_int32,
        nbins: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetAlignedStats(
        pixa: *mut PIXA,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtractColumnFromEachPix(pixa: *mut PIXA, col: l_int32, pixd: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRowStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        colvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColumnStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        rowvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetPixelColumn(pix: *mut PIX, col: l_int32, colvect: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixThresholdForFgBg(
        pixs: *mut PIX,
        factor: l_int32,
        thresh: l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitDistributionFgBg(
        pixs: *mut PIX,
        scorefract: l_float32,
        factor: l_int32,
        pthresh: *mut l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindDimensions(pixa: *mut PIXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixFindAreaPerimRatio(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimToAreaRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimToAreaRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimSizeRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimSizeRatio(pixs: *mut PIX, tab: *mut l_int32, pratio: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFraction(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFraction(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFractionMasked(pixa: *mut PIXA, pixm: *mut PIX, debug: l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFractionMasked(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixm: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindWidthHeightRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixaFindWidthHeightProduct(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindOverlapFraction(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x2: l_int32,
        y2: l_int32,
        tab: *mut l_int32,
        pratio: *mut l_float32,
        pnoverlap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleComps(
        pixs: *mut PIX,
        dist: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConformsToRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pconforms: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipRectangles(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixClipRectangle(pixs: *mut PIX, box_: *mut BOX, pboxc: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixClipRectangleWithBorder(
        pixs: *mut PIX,
        box_: *mut BOX,
        maxbord: l_int32,
        pboxn: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixClipMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        outval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCropToMatch(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        ppixd1: *mut *mut PIX,
        ppixd2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropToSize(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeToMatch(pixs: *mut PIX, pixt: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFilterComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeSymmetricMask(
        w: l_int32,
        h: l_int32,
        hf: l_float32,
        vf: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeFrameMask(
        w: l_int32,
        h: l_int32,
        hf1: l_float32,
        hf2: l_float32,
        vf1: l_float32,
        vf2: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeCoveringOfRectangles(pixs: *mut PIX, maxiters: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFractionFgInMask(pix1: *mut PIX, pix2: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixClipToForeground(pixs: *mut PIX, ppixd: *mut *mut PIX, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixTestClipToForeground(pixs: *mut PIX, pcanclip: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToForeground(
        pixs: *mut PIX,
        boxs: *mut BOX,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForForeground(
        pixs: *mut PIX,
        box_: *mut BOX,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToEdges(
        pixs: *mut PIX,
        boxs: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForEdge(
        pixs: *mut PIX,
        box_: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExtractOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> l_float32;
}
extern "C" {
    pub fn pixAverageIntensityProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixReversalProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        minreversal: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixWindowedVarianceOnLine(
        pixs: *mut PIX,
        dir: l_int32,
        loc: l_int32,
        c1: l_int32,
        c2: l_int32,
        size: l_int32,
        pnad: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMinMaxNearLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        dist: l_int32,
        direction: l_int32,
        pnamin: *mut *mut NUMA,
        pnamax: *mut *mut NUMA,
        pminave: *mut l_float32,
        pmaxave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRankRowTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRankColumnTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixaCreate(n: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromPix(
        pixs: *mut PIX,
        n: l_int32,
        cellw: l_int32,
        cellh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromBoxa(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        start: l_int32,
        num: l_int32,
        pcropwarn: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitPix(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaDestroy(ppixa: *mut *mut PIXA);
}
extern "C" {
    pub fn pixaCopy(pixa: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPix(pixa: *mut PIXA, pix: *mut PIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAddBox(pixa: *mut PIXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaExtendArrayToSize(pixa: *mut PIXA, size: size_t) -> l_ok;
}
extern "C" {
    pub fn pixaGetCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaChangeRefcount(pixa: *mut PIXA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetPix(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetPixDimensions(
        pixa: *mut PIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetBoxa(pixa: *mut PIXA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaGetBoxaCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetBox(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixaGetBoxGeometry(
        pixa: *mut PIXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetBoxa(pixa: *mut PIXA, boxa: *mut BOXA, accesstype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetPixArray(pixa: *mut PIXA) -> *mut *mut PIX;
}
extern "C" {
    pub fn pixaVerifyDepth(pixa: *mut PIXA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaVerifyDimensions(
        pixa: *mut PIXA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaIsFull(pixa: *mut PIXA, pfullpa: *mut l_int32, pfullba: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCountText(pixa: *mut PIXA, pntext: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaSetText(
        pixa: *mut PIXA,
        text: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetLinePtrs(
        pixa: *mut PIXA,
        psize: *mut l_int32,
    ) -> *mut *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixaWriteStreamInfo(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReplacePix(pixa: *mut PIXA, index: l_int32, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaInsertPix(pixa: *mut PIXA, index: l_int32, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePix(pixa: *mut PIXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePixAndSave(
        pixa: *mut PIXA,
        index: l_int32,
        ppix: *mut *mut PIX,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveSelected(pixa: *mut PIXA, naindex: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaInitFull(pixa: *mut PIXA, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaClear(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaJoin(pixad: *mut PIXA, pixas: *mut PIXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaInterleave(pixa1: *mut PIXA, pixa2: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaJoin(paad: *mut PIXAA, paas: *mut PIXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaCreate(n: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaCreateFromPixa(
        pixa: *mut PIXA,
        n: l_int32,
        type_: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaDestroy(ppaa: *mut *mut PIXAA);
}
extern "C" {
    pub fn pixaaAddPixa(paa: *mut PIXAA, pixa: *mut PIXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaAddPix(
        paa: *mut PIXAA,
        index: l_int32,
        pix: *mut PIX,
        box_: *mut BOX,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaAddBox(paa: *mut PIXAA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaGetCount(paa: *mut PIXAA, pna: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixaaGetPixa(paa: *mut PIXAA, index: l_int32, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaGetBoxa(paa: *mut PIXAA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaaGetPix(
        paa: *mut PIXAA,
        index: l_int32,
        ipix: l_int32,
        accessflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaVerifyDepth(paa: *mut PIXAA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaVerifyDimensions(
        paa: *mut PIXAA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaIsFull(paa: *mut PIXAA, pfull: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaInitFull(paa: *mut PIXAA, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaReplacePixa(paa: *mut PIXAA, index: l_int32, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaClear(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaTruncate(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadStream(fp: *mut FILE) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadMem(data: *const l_uint8, size: size_t) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteDebug(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWrite(filename: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStream(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReadBoth(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadStream(fp: *mut FILE) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadMem(data: *const l_uint8, size: size_t) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaWrite(filename: *const ::std::os::raw::c_char, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteStream(fp: *mut FILE, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaccCreate(w: l_int32, h: l_int32, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccCreateFromPix(pix: *mut PIX, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccDestroy(ppixacc: *mut *mut PIXACC);
}
extern "C" {
    pub fn pixaccFinal(pixacc: *mut PIXACC, outdepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetPix(pixacc: *mut PIXACC) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetOffset(pixacc: *mut PIXACC) -> l_int32;
}
extern "C" {
    pub fn pixaccAdd(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccSubtract(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConst(pixacc: *mut PIXACC, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConstAccumulate(pixacc: *mut PIXACC, pix: *mut PIX, factor: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixSelectBySize(
        pixs: *mut PIX,
        width: l_int32,
        height: l_int32,
        connectivity: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectBySize(
        pixas: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeSizeIndicator(
        pixa: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSelectByPerimToAreaRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimToAreaRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByPerimSizeRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimSizeRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByAreaFraction(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByAreaFraction(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByArea(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByArea(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByWidthHeightRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByWidthHeightRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectByNumConnComp(
        pixas: *mut PIXA,
        nmin: l_int32,
        nmax: l_int32,
        connectivity: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectWithIndicator(
        pixas: *mut PIXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixRemoveWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixAddWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaSelectWithString(
        pixas: *mut PIXA,
        str_: *const ::std::os::raw::c_char,
        perror: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRenderComponent(pixs: *mut PIX, pixa: *mut PIXA, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaBinSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSortByIndex(pixas: *mut PIXA, naindex: *mut NUMA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSort2dByIndex(pixas: *mut PIXA, naa: *mut NUMAA, copyflag: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaSelectRange(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSelectRange(
        paas: *mut PIXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSize(paas: *mut PIXAA, wd: l_int32, hd: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSizeVar(paas: *mut PIXAA, nawd: *mut NUMA, nahd: *mut NUMA) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaScaleToSize(pixas: *mut PIXA, wd: l_int32, hd: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleToSizeRel(pixas: *mut PIXA, delw: l_int32, delh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScale(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleBySampling(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32)
        -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotate(
        pixas: *mut PIXA,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotateOrth(pixas: *mut PIXA, rotation: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaTranslate(
        pixas: *mut PIXA,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddBorderGeneral(
        pixad: *mut PIXA,
        pixas: *mut PIXA,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaFlattenToPixa(
        paa: *mut PIXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSizeRange(
        paa: *mut PIXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSizeRange(
        pixa: *mut PIXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaClipToPix(pixas: *mut PIXA, pixs: *mut PIX) -> *mut PIXA;
}
extern "C" {
    pub fn pixaClipToForeground(
        pixas: *mut PIXA,
        ppixad: *mut *mut PIXA,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetRenderingDepth(pixa: *mut PIXA, pdepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaHasColor(pixa: *mut PIXA, phascolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAnyColormaps(pixa: *mut PIXA, phascmap: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetDepthInfo(pixa: *mut PIXA, pmaxdepth: *mut l_int32, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToSameDepth(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToGivenDepth(pixas: *mut PIXA, depth: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaEqual(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetFullSizeBoxa(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaDisplay(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayRandomCmap(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayLinearly(
        pixas: *mut PIXA,
        direction: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayOnLattice(
        pixa: *mut PIXA,
        cellw: l_int32,
        cellh: l_int32,
        pncols: *mut l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayUnsplit(
        pixa: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiled(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        background: l_int32,
        spacing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInRows(
        pixa: *mut PIXA,
        outdepth: l_int32,
        maxwidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInColumns(
        pixas: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledAndScaled(
        pixa: *mut PIXA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledWithText(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledByIndex(
        pixa: *mut PIXA,
        na: *mut NUMA,
        width: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayPairTiledInColumns(
        pixas1: *mut PIXA,
        pixas2: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing1: l_int32,
        spacing2: l_int32,
        border1: l_int32,
        border2: l_int32,
        fontsize: l_int32,
        startindex: l_int32,
        sa: *mut SARRAY,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplay(paa: *mut PIXAA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayByPixa(
        paa: *mut PIXAA,
        maxnx: l_int32,
        scalefactor: l_float32,
        hspacing: l_int32,
        vspacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayTiledAndScaled(
        paa: *mut PIXAA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo1(pixas: *mut PIXA, thresh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8(pixas: *mut PIXA, cmapflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8Colormap(pixas: *mut PIXA, dither: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo32(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConstrainedSelect(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectToPdf(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        color: l_uint32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaMakeFromTiledPixa(
        pixas: *mut PIXA,
        w: l_int32,
        h: l_int32,
        nsamp: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeFromTiledPix(
        pixs: *mut PIX,
        w: l_int32,
        h: l_int32,
        start: l_int32,
        num: l_int32,
        boxa: *mut BOXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixGetTileCount(pix: *mut PIX, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaDisplayMultiTiled(
        pixas: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        maxw: l_int32,
        maxh: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitIntoFiles(
        pixas: *mut PIXA,
        nsplit: l_int32,
        scale: l_float32,
        outwidth: l_int32,
        write_pixa: l_int32,
        write_pix: l_int32,
        write_pdf: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpFiles(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpPixa(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToNUpPixa(
        pixas: *mut PIXA,
        sa: *mut SARRAY,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCompareInPdf(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsCreate(
        minsize: size_t,
        smallest: size_t,
        numalloc: *mut NUMA,
        logfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsDestroy();
}
extern "C" {
    pub fn pmsCustomAlloc(nbytes: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsCustomDealloc(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pmsGetAlloc(nbytes: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsGetLevelForAlloc(nbytes: size_t, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsGetLevelForDealloc(data: *mut ::std::os::raw::c_void, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsLogInfo();
}
extern "C" {
    pub fn pixAddConstantGray(pixs: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstantGray(pixs: *mut PIX, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAddGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtractGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyGray(pixs: *mut PIX, pixg: *mut PIX, norm: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdToValue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        threshval: l_int32,
        setval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInitAccumulate(w: l_int32, h: l_int32, offset: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulate(pixs: *mut PIX, offset: l_uint32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulateThreshold(
        pixs: *mut PIX,
        offset: l_uint32,
        threshold: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAccumulate(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstAccumulate(pixs: *mut PIX, factor: l_float32, offset: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDifference(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRGB(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMinOrMax(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRange(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRangeRGB(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn linearScaleRGBVal(sval: l_uint32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn logScaleRGBVal(sval: l_uint32, tab: *mut l_float32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn makeLogBase2Tab() -> *mut l_float32;
}
extern "C" {
    pub fn getLogBase2(val: l_int32, logtab: *mut l_float32) -> l_float32;
}
extern "C" {
    pub fn pixcompCreateFromPix(pix: *mut PIX, comptype: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromString(
        data: *mut l_uint8,
        size: size_t,
        copyflag: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompDestroy(ppixc: *mut *mut PIXC);
}
extern "C" {
    pub fn pixcompCopy(pixcs: *mut PIXC) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompGetDimensions(
        pixc: *mut PIXC,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompGetParameters(
        pixc: *mut PIXC,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
        pcomptype: *mut l_int32,
        pcmapflag: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompDetermineFormat(
        comptype: l_int32,
        d: l_int32,
        cmapflag: l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCreateFromPixcomp(pixc: *mut PIXC) -> *mut PIX;
}
extern "C" {
    pub fn pixacompCreate(n: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateWithInit(
        n: l_int32,
        offset: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromPixa(
        pixa: *mut PIXA,
        comptype: l_int32,
        accesstype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromSA(sa: *mut SARRAY, comptype: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompDestroy(ppixac: *mut *mut PIXAC);
}
extern "C" {
    pub fn pixacompAddPix(pixac: *mut PIXAC, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompAddPixcomp(pixac: *mut PIXAC, pixc: *mut PIXC, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePix(
        pixac: *mut PIXAC,
        index: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePixcomp(pixac: *mut PIXAC, index: l_int32, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixacompAddBox(pixac: *mut PIXAC, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompGetCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetPixcomp(pixac: *mut PIXAC, index: l_int32, copyflag: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixacompGetPix(pixac: *mut PIXAC, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixacompGetPixDimensions(
        pixac: *mut PIXAC,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetBoxa(pixac: *mut PIXAC, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixacompGetBoxaCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetBox(pixac: *mut PIXAC, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixacompGetBoxGeometry(
        pixac: *mut PIXAC,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetOffset(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompSetOffset(pixac: *mut PIXAC, offset: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCreateFromPixacomp(pixac: *mut PIXAC, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixacompJoin(
        pixacd: *mut PIXAC,
        pixacs: *mut PIXAC,
        istart: l_int32,
        iend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompInterleave(pixac1: *mut PIXAC, pixac2: *mut PIXAC) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadStream(fp: *mut FILE) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadMem(data: *const l_uint8, size: size_t) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompWrite(filename: *const ::std::os::raw::c_char, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStream(fp: *mut FILE, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pixac: *mut PIXAC,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdf(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdfData(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompFastConvertToPdfData(
        pixac: *mut PIXAC,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStreamInfo(
        fp: *mut FILE,
        pixac: *mut PIXAC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteStreamInfo(
        fp: *mut FILE,
        pixc: *mut PIXC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompDisplayTiledAndScaled(
        pixac: *mut PIXAC,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixacompWriteFiles(pixac: *mut PIXAC, subdir: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteFile(rootname: *const ::std::os::raw::c_char, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixThreshold8(
        pixs: *mut PIX,
        d: l_int32,
        nlevels: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormapGeneral(pixs: *mut PIX, type_: l_int32, ifnocmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormap(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddGrayColormap8(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixAddMinimalGrayColormap8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToLuminance(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayGeneral(
        pixs: *mut PIX,
        type_: l_int32,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGray(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayFast(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayMinMax(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGraySatBoost(pixs: *mut PIX, refval: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToBinaryArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_int32,
        relation: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap8(pixs: *mut PIX, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixColorizeGray(pixs: *mut PIX, color: l_uint32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToColormap(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertCmapTo1(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantizeIfFewColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        mingraycolors: l_int32,
        octlevel: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvert16To8(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToFalseColor(pixs: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnpackBinary(pixs: *mut PIX, depth: l_int32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To16(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint16,
        val1: l_uint16,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To32(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint32,
        val1: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8(pixd: *mut PIX, pixs: *mut PIX, val0: l_uint8, val1: l_uint8)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert2To8(
        pixs: *mut PIX,
        val0: l_uint8,
        val1: l_uint8,
        val2: l_uint8,
        val3: l_uint8,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert4To8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To16(pixs: *mut PIX, leftshift: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To4(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1Adaptive(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1(pixs: *mut PIX, threshold: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1BySampling(pixs: *mut PIX, factor: l_int32, threshold: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8BySampling(pixs: *mut PIX, factor: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Colormap(pixs: *mut PIX, dither: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32BySampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Or32(pixs: *mut PIX, copyflag: l_int32, warnflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert24To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To24(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To16(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To8(pixs: *mut PIX, type16: l_int32, type8: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveAlpha(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaTo1bpp(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertLossless(pixs: *mut PIX, d: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertForPSWrap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertColorToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setNeutralBoostVal(val: l_int32);
}
extern "C" {
    pub fn pixConnCompTransform(pixs: *mut PIX, connect: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompAreaTransform(pixs: *mut PIX, connect: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompIncrInit(
        pixs: *mut PIX,
        conn: l_int32,
        ppixd: *mut *mut PIX,
        pptaa: *mut *mut PTAA,
        pncc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnCompIncrAdd(
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pncc: *mut l_int32,
        x: l_float32,
        y: l_float32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetSortedNeighborValues(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        conn: l_int32,
        pneigh: *mut *mut l_int32,
        pnvals: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixLocToColorTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingCreate(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        w: l_int32,
        h: l_int32,
        xoverlap: l_int32,
        yoverlap: l_int32,
    ) -> *mut PIXTILING;
}
extern "C" {
    pub fn pixTilingDestroy(ppt: *mut *mut PIXTILING);
}
extern "C" {
    pub fn pixTilingGetCount(pt: *mut PIXTILING, pnx: *mut l_int32, pny: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetSize(pt: *mut PIXTILING, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetTile(pt: *mut PIXTILING, i: l_int32, j: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingNoStripOnPaint(pt: *mut PIXTILING) -> l_ok;
}
extern "C" {
    pub fn pixTilingPaintTile(
        pixd: *mut PIX,
        i: l_int32,
        j: l_int32,
        pixs: *mut PIX,
        pt: *mut PIXTILING,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPng(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPng(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPng(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemPng(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn isPngInterlaced(
        filename: *const ::std::os::raw::c_char,
        pinterlaced: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngColormapInfo(
        fp: *mut FILE,
        pcmap: *mut *mut PIXCMAP,
        ptransparency: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePng(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPng(fp: *mut FILE, pix: *mut PIX, gamma: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetZlibCompression(pix: *mut PIX, compval: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_pngSetReadStrip16To8(flag: l_int32);
}
extern "C" {
    pub fn pixReadMemPng(filedata: *const l_uint8, filesize: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemPng(
        pfiledata: *mut *mut l_uint8,
        pfilesize: *mut size_t,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPnm(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPnm(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPnm(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamAsciiPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPam(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemPnm(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemPnm(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPnm(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPam(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixProjectiveSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjective(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getProjectiveXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesToPS(
        sa: *mut SARRAY,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesFittedToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesFittedToPS(
        sa: *mut SARRAY,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageCompressedToPSFile(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedPagesToPS(
        pagedir: *const ::std::os::raw::c_char,
        pagestr: *const ::std::os::raw::c_char,
        page_numpre: l_int32,
        maskdir: *const ::std::os::raw::c_char,
        maskstr: *const ::std::os::raw::c_char,
        mask_numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteSegmentedPageToPS(
        pixs: *mut PIX,
        pixm: *mut PIX,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMixedToPS(
        pixb: *mut PIX,
        pixc: *mut PIX,
        scale: l_float32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteCompressedToPS(
        pixa: *mut PIXA,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteCompressedToPS(
        pix: *mut PIX,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPS(
        fp: *mut FILE,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStringPS(
        pixs: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn generateUncompressedPS(
        hexdata: *mut ::std::os::raw::c_char,
        w: l_int32,
        h: l_int32,
        d: l_int32,
        psbpl: l_int32,
        bps: l_int32,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        boxflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertJpegToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertJpegToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        maskflag: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        fillfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPS(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn getResLetterPage(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn getResA4Page(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_psWriteBoundingBox(flag: l_int32);
}
extern "C" {
    pub fn ptaCreate(n: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaCreateFromNuma(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaDestroy(ppta: *mut *mut PTA);
}
extern "C" {
    pub fn ptaCopy(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCopyRange(ptas: *mut PTA, istart: l_int32, iend: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaClone(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEmpty(pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaAddPt(pta: *mut PTA, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaInsertPt(pta: *mut PTA, index: l_int32, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaRemovePt(pta: *mut PTA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaGetRefcount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaChangeRefcount(pta: *mut PTA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetCount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaGetPt(pta: *mut PTA, index: l_int32, px: *mut l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetIPt(pta: *mut PTA, index: l_int32, px: *mut l_int32, py: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaSetPt(pta: *mut PTA, index: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetArrays(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn ptaRead(filename: *const ::std::os::raw::c_char) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadStream(fp: *mut FILE) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadMem(data: *const l_uint8, size: size_t) -> *mut PTA;
}
extern "C" {
    pub fn ptaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaWrite(filename: *const ::std::os::raw::c_char, pta: *mut PTA, type_: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn ptaWriteStream(fp: *mut FILE, pta: *mut PTA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaCreate(n: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaDestroy(pptaa: *mut *mut PTAA);
}
extern "C" {
    pub fn ptaaAddPta(ptaa: *mut PTAA, pta: *mut PTA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaGetCount(ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn ptaaGetPta(ptaa: *mut PTAA, index: l_int32, accessflag: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetPt(
        ptaa: *mut PTAA,
        ipta: l_int32,
        jpt: l_int32,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaInitFull(ptaa: *mut PTAA, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaReplacePta(ptaa: *mut PTAA, index: l_int32, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaAddPt(ptaa: *mut PTAA, ipta: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaaTruncate(ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn ptaaRead(filename: *const ::std::os::raw::c_char) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadStream(fp: *mut FILE) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadMem(data: *const l_uint8, size: size_t) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWrite(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteStream(fp: *mut FILE, ptaa: *mut PTAA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSubsample(ptas: *mut PTA, subfactor: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaJoin(ptad: *mut PTA, ptas: *mut PTA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaJoin(ptaad: *mut PTAA, ptaas: *mut PTAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaReverse(ptas: *mut PTA, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaTranspose(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCyclicPerm(ptas: *mut PTA, xs: l_int32, ys: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaSelectRange(ptas: *mut PTA, first: l_int32, last: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetBoundingRegion(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn ptaGetRange(
        pta: *mut PTA,
        pminx: *mut l_float32,
        pmaxx: *mut l_float32,
        pminy: *mut l_float32,
        pmaxy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetInsideBox(ptas: *mut PTA, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixFindCornerPixels(pixs: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaContainsPt(pta: *mut PTA, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaTestIntersection(pta1: *mut PTA, pta2: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaTransform(
        ptas: *mut PTA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaPtInsidePolygon(
        pta: *mut PTA,
        x: l_float32,
        y: l_float32,
        pinside: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_angleBetweenVectors(
        x1: l_float32,
        y1: l_float32,
        x2: l_float32,
        y2: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn ptaPolygonIsConvex(pta: *mut PTA, pisconvex: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetMinMax(
        pta: *mut PTA,
        pxmin: *mut l_float32,
        pymin: *mut l_float32,
        pxmax: *mut l_float32,
        pymax: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSelectByValue(
        ptas: *mut PTA,
        xth: l_float32,
        yth: l_float32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaCropToMask(ptas: *mut PTA, pixm: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetLinearLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuadraticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetCubicLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuarticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pe: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyLinearLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyQuadraticLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn applyLinearFit(a: l_float32, b: l_float32, x: l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn applyQuadraticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyCubicFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyQuarticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        e: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPlotAlongPta(
        pixs: *mut PIX,
        pta: *mut PTA,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetPixelsFromPix(pixs: *mut PIX, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixGenerateFromPta(pta: *mut PTA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn ptaGetBoundaryPixels(pixs: *mut PIX, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetBoundaryPixels(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaIndexLabeledPixels(pixs: *mut PIX, pncc: *mut l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetNeighborPixLocs(pixs: *mut PIX, x: l_int32, y: l_int32, conn: l_int32)
        -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta1(na: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta2(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToNuma(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixDisplayPta(pixd: *mut PIX, pixs: *mut PIX, pta: *mut PTA) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pta: *mut PTA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ptaReplicatePattern(
        ptas: *mut PTA,
        pixp: *mut PIX,
        ptap: *mut PTA,
        cx: l_int32,
        cy: l_int32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDisplayPtaa(pixs: *mut PIX, ptaa: *mut PTAA) -> *mut PIX;
}
extern "C" {
    pub fn ptaSort(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetSortIndex(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSortByIndex(ptas: *mut PTA, naindex: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaaSortByIndex(ptaas: *mut PTAA, naindex: *mut NUMA) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetRankValue(
        pta: *mut PTA,
        fract: l_float32,
        ptasort: *mut PTA,
        sorttype: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSort2d(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEqual(pta1: *mut PTA, pta2: *mut PTA, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_asetCreateFromPta(pta: *mut PTA) -> *mut L_ASET;
}
extern "C" {
    pub fn ptaRemoveDupsByAset(ptas: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromPta(pta: *mut PTA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn ptaRemoveDupsByHmap(
        ptas: *mut PTA,
        pptad: *mut *mut PTA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptraCreate(n: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraDestroy(ppa: *mut *mut L_PTRA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraAdd(pa: *mut L_PTRA, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn ptraInsert(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        shiftflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraRemove(
        pa: *mut L_PTRA,
        index: l_int32,
        flag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraRemoveLast(pa: *mut L_PTRA) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraReplace(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        freeflag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraSwap(pa: *mut L_PTRA, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraCompactArray(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraReverse(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraJoin(pa1: *mut L_PTRA, pa2: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraGetMaxIndex(pa: *mut L_PTRA, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetActualCount(pa: *mut L_PTRA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetPtrToItem(pa: *mut L_PTRA, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraaCreate(n: l_int32) -> *mut L_PTRAA;
}
extern "C" {
    pub fn ptraaDestroy(ppaa: *mut *mut L_PTRAA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraaGetSize(paa: *mut L_PTRAA, psize: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraaInsertPtra(paa: *mut L_PTRAA, index: l_int32, pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraaGetPtra(paa: *mut L_PTRAA, index: l_int32, accessflag: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraaFlattenToPtra(paa: *mut L_PTRAA) -> *mut L_PTRA;
}
extern "C" {
    pub fn pixQuadtreeMean(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        pfpixa: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixQuadtreeVariance(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pfpixa_v: *mut *mut FPIXA,
        pfpixa_rv: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixma: *mut PIX,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaQuadtreeRegions(w: l_int32, h: l_int32, nlevels: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn quadtreeGetParent(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeGetChildren(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval00: *mut l_float32,
        pval10: *mut l_float32,
        pval01: *mut l_float32,
        pval11: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeMaxLevels(w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaDisplayQuadtree(fpixa: *mut FPIXA, factor: l_int32, fontsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn lqueueCreate(nalloc: l_int32) -> *mut L_QUEUE;
}
extern "C" {
    pub fn lqueueDestroy(plq: *mut *mut L_QUEUE, freeflag: l_int32);
}
extern "C" {
    pub fn lqueueAdd(lq: *mut L_QUEUE, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lqueueRemove(lq: *mut L_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lqueueGetCount(lq: *mut L_QUEUE) -> l_int32;
}
extern "C" {
    pub fn lqueuePrint(fp: *mut FILE, lq: *mut L_QUEUE) -> l_ok;
}
extern "C" {
    pub fn pixRankFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterRGB(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterGray(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixMedianFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterWithScaling(
        pixs: *mut PIX,
        wf: l_int32,
        hf: l_int32,
        rank: l_float32,
        scalefactor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_rbtreeCreate(keytype: l_int32) -> *mut L_RBTREE;
}
extern "C" {
    pub fn l_rbtreeLookup(t: *mut L_RBTREE, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_rbtreeInsert(t: *mut L_RBTREE, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDelete(t: *mut L_RBTREE, key: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDestroy(pt: *mut *mut L_RBTREE);
}
extern "C" {
    pub fn l_rbtreeGetFirst(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetNext(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetLast(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetPrev(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetCount(t: *mut L_RBTREE) -> l_int32;
}
extern "C" {
    pub fn l_rbtreePrint(fp: *mut FILE, t: *mut L_RBTREE);
}
extern "C" {
    pub fn pixProcessBarcodes(
        pixs: *mut PIX,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixExtractBarcodes(pixs: *mut PIX, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixReadBarcodes(
        pixa: *mut PIXA,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadBarcodeWidths(pixs: *mut PIX, method: l_int32, debugflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixLocateBarcodes(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixb: *mut *mut PIX,
        ppixm: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixDeskewBarcode(
        pixs: *mut PIX,
        pixb: *mut PIX,
        box_: *mut BOX,
        margin: l_int32,
        threshold: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBarcodeWidths1(
        pixs: *mut PIX,
        thresh: l_float32,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeWidths2(
        pixs: *mut PIX,
        thresh: l_float32,
        pwidth: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeCrossings(
        pixs: *mut PIX,
        thresh: l_float32,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWidth(
        nas: *mut NUMA,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWindow(
        nas: *mut NUMA,
        ratio: l_float32,
        pwidth: *mut l_float32,
        pfirstloc: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaReadFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadFilesSA(sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn pixRead(filename: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn pixReadWithHint(filename: *const ::std::os::raw::c_char, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadIndexed(sa: *mut SARRAY, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStream(fp: *mut FILE, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeader(
        filename: *const ::std::os::raw::c_char,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findFileFormat(filename: *const ::std::os::raw::c_char, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatStream(fp: *mut FILE, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatBuffer(buf: *const l_uint8, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fileFormatIsTiff(fp: *mut FILE) -> l_int32;
}
extern "C" {
    pub fn pixReadMem(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeaderMem(
        data: *const l_uint8,
        size: size_t,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageFileInfo(
        filename: *const ::std::os::raw::c_char,
        fpout: *mut FILE,
        headeronly: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ioFormatTest(filename: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn recogCreateFromRecog(
        recs: *mut L_RECOG,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixa(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixaNoFinish(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreate(
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogDestroy(precog: *mut *mut L_RECOG);
}
extern "C" {
    pub fn recogGetCount(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogSetParams(
        recog: *mut L_RECOG,
        type_: l_int32,
        min_nopad: l_int32,
        max_wh_ratio: l_float32,
        max_ht_ratio: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassIndex(
        recog: *mut L_RECOG,
        val: l_int32,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogStringToIndex(
        recog: *mut L_RECOG,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassString(
        recog: *mut L_RECOG,
        index: l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_convertCharstrToInt(str_: *const ::std::os::raw::c_char, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn recogRead(filename: *const ::std::os::raw::c_char) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadStream(fp: *mut FILE) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadMem(data: *const l_uint8, size: size_t) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogWrite(filename: *const ::std::os::raw::c_char, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteStream(fp: *mut FILE, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, recog: *mut L_RECOG)
        -> l_ok;
}
extern "C" {
    pub fn recogExtractPixa(recog: *mut L_RECOG) -> *mut PIXA;
}
extern "C" {
    pub fn recogDecode(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        nlevels: l_int32,
        ppixdb: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn recogCreateDid(recog: *mut L_RECOG, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogDestroyDid(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogDidExists(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogGetDid(recog: *mut L_RECOG) -> *mut L_RDID;
}
extern "C" {
    pub fn recogSetChannelParams(recog: *mut L_RECOG, nlevels: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyMultiple(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdb: *mut *mut PIX,
        debugsplit: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogSplitIntoCharacters(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestRow(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pboxa: *mut *mut BOXA,
        pnascore: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        psachar: *mut *mut SARRAY,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestChar(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pbox: *mut *mut BOX,
        pscore: *mut l_float32,
        pindex: *mut l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPixa(recog: *mut L_RECOG, pixa: *mut PIXA, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPix(recog: *mut L_RECOG, pixs: *mut PIX, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogSkipIdentify(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn rchaDestroy(prcha: *mut *mut L_RCHA);
}
extern "C" {
    pub fn rchDestroy(prch: *mut *mut L_RCH);
}
extern "C" {
    pub fn rchaExtract(
        rcha: *mut L_RCHA,
        pnaindex: *mut *mut NUMA,
        pnascore: *mut *mut NUMA,
        psatext: *mut *mut SARRAY,
        pnasample: *mut *mut NUMA,
        pnaxloc: *mut *mut NUMA,
        pnayloc: *mut *mut NUMA,
        pnawidth: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn rchExtract(
        rch: *mut L_RCH,
        pindex: *mut l_int32,
        pscore: *mut l_float32,
        ptext: *mut *mut ::std::os::raw::c_char,
        psample: *mut l_int32,
        pxloc: *mut l_int32,
        pyloc: *mut l_int32,
        pwidth: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessToIdentify(recog: *mut L_RECOG, pixs: *mut PIX, pad: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn recogExtractNumbers(
        recog: *mut L_RECOG,
        boxas: *mut BOXA,
        scorethresh: l_float32,
        spacethresh: l_int32,
        pbaa: *mut *mut BOXAA,
        pnaa: *mut *mut NUMAA,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn showExtractNumbers(
        pixs: *mut PIX,
        sa: *mut SARRAY,
        baa: *mut BOXAA,
        naa: *mut NUMAA,
        ppixdb: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        ppix: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogAddSample(recog: *mut L_RECOG, pix: *mut PIX, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogModifyTemplate(recog: *mut L_RECOG, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn recogAverageSamples(precog: *mut *mut L_RECOG, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAccumulateSamples(
        pixa: *mut PIXA,
        pta: *mut PTA,
        ppixd: *mut *mut PIX,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogTrainingFinished(
        precog: *mut *mut L_RECOG,
        modifyflag: l_int32,
        minsize: l_int32,
        minfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogFilterPixaBySize(
        pixas: *mut PIXA,
        setsize: l_int32,
        maxkeep: l_int32,
        max_ht_ratio: l_float32,
        pna: *mut *mut NUMA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogSortPixaByClass(pixa: *mut PIXA, setsize: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn recogRemoveOutliers1(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers1(
        pixas: *mut PIXA,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogRemoveOutliers2(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers2(
        pixas: *mut PIXA,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainFromBoot(
        recogboot: *mut L_RECOG,
        pixas: *mut PIXA,
        minscore: l_float32,
        threshold: l_int32,
        debug: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogPadDigitTrainingSet(
        precog: *mut *mut L_RECOG,
        scaleh: l_int32,
        linew: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIsPaddingNeeded(recog: *mut L_RECOG, psa: *mut *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn recogAddDigitPadTemplates(recog: *mut L_RECOG, sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn recogMakeBootDigitRecog(
        nsamp: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        maxyshift: l_int32,
        debug: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogMakeBootDigitTemplates(nsamp: l_int32, debug: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn recogShowContent(
        fp: *mut FILE,
        recog: *mut L_RECOG,
        index: l_int32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogDebugAverages(precog: *mut *mut L_RECOG, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogShowAverageTemplates(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogShowMatchesInRange(
        recog: *mut L_RECOG,
        pixa: *mut PIXA,
        minscore: l_float32,
        maxscore: l_float32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogShowMatch(
        recog: *mut L_RECOG,
        pix1: *mut PIX,
        pix2: *mut PIX,
        box_: *mut BOX,
        index: l_int32,
        score: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn regTestSetup(
        argc: l_int32,
        argv: *mut *mut ::std::os::raw::c_char,
        prp: *mut *mut L_REGPARAMS,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCleanup(rp: *mut L_REGPARAMS) -> l_ok;
}
extern "C" {
    pub fn regTestCompareValues(
        rp: *mut L_REGPARAMS,
        val1: l_float32,
        val2: l_float32,
        delta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCompareStrings(
        rp: *mut L_REGPARAMS,
        string1: *mut l_uint8,
        bytes1: size_t,
        string2: *mut l_uint8,
        bytes2: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestComparePix(rp: *mut L_REGPARAMS, pix1: *mut PIX, pix2: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn regTestCompareSimilarPix(
        rp: *mut L_REGPARAMS,
        pix1: *mut PIX,
        pix2: *mut PIX,
        mindiff: l_int32,
        maxfract: l_float32,
        printstats: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCheckFile(rp: *mut L_REGPARAMS, localname: *const ::std::os::raw::c_char)
        -> l_ok;
}
extern "C" {
    pub fn regTestCompareFiles(rp: *mut L_REGPARAMS, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWritePixAndCheck(rp: *mut L_REGPARAMS, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWriteDataAndCheck(
        rp: *mut L_REGPARAMS,
        data: *mut ::std::os::raw::c_void,
        nbytes: size_t,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestGenLocalFilename(
        rp: *mut L_REGPARAMS,
        index: l_int32,
        format: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixRasterop(
        pixd: *mut PIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropVip(
        pixd: *mut PIX,
        bx: l_int32,
        bw: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropHip(
        pixd: *mut PIX,
        by: l_int32,
        bh: l_int32,
        hshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixTranslate(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRasteropIP(
        pixd: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropFullImage(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn rasteropUniLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
    );
}
extern "C" {
    pub fn rasteropLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        datas: *mut l_uint32,
        spixw: l_int32,
        spixh: l_int32,
        swpl: l_int32,
        sx: l_int32,
        sy: l_int32,
    );
}
extern "C" {
    pub fn rasteropVipLow(
        data: *mut l_uint32,
        pixw: l_int32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        x: l_int32,
        w: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn rasteropHipLow(
        data: *mut l_uint32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        y: l_int32,
        h: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn pixRotate(
        pixs: *mut PIX,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEmbedForRotation(
        pixs: *mut PIX,
        angle: l_float32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBySampling(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBinaryNice(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateWithAlpha(
        pixs: *mut PIX,
        angle: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAM(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColor(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGray(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMCorner(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorCorner(pixs: *mut PIX, angle: l_float32, fillval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGrayCorner(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorFast(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateOrth(pixs: *mut PIX, quads: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate180(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate90(pixs: *mut PIX, direction: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipLR(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipTB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate2Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate3Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearIP(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRotateShearCenter(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearCenterIP(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixStrokeWidthTransform(
        pixs: *mut PIX,
        color: l_int32,
        depth: l_int32,
        nangles: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunlengthTransform(
        pixs: *mut PIX,
        color: l_int32,
        direction: l_int32,
        depth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHorizontalRuns(
        pix: *mut PIX,
        y: l_int32,
        xstart: *mut l_int32,
        xend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindVerticalRuns(
        pix: *mut PIX,
        x: l_int32,
        ystart: *mut l_int32,
        yend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxRuns(pix: *mut PIX, direction: l_int32, pnastart: *mut *mut NUMA)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindMaxHorizontalRunOnLine(
        pix: *mut PIX,
        y: l_int32,
        pxstart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxVerticalRunOnLine(
        pix: *mut PIX,
        x: l_int32,
        pystart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn runlengthMembershipOnLine(
        buffer: *mut l_int32,
        size: l_int32,
        depth: l_int32,
        start: *mut l_int32,
        end: *mut l_int32,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeMSBitLocTab(bitval: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn sarrayCreate(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateInitialized(
        n: l_int32,
        initstr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateWordsFromString(string: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateLinesFromString(
        string: *const ::std::os::raw::c_char,
        blankflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayDestroy(psa: *mut *mut SARRAY);
}
extern "C" {
    pub fn sarrayCopy(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayClone(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayAddString(
        sa: *mut SARRAY,
        string: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayRemoveString(sa: *mut SARRAY, index: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayReplaceString(
        sa: *mut SARRAY,
        index: l_int32,
        newstr: *mut ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayClear(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayGetCount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayGetArray(
        sa: *mut SARRAY,
        pnalloc: *mut l_int32,
        pn: *mut l_int32,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetString(
        sa: *mut SARRAY,
        index: l_int32,
        copyflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetRefcount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayChangeRefcount(sa: *mut SARRAY, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn sarrayToString(sa: *mut SARRAY, addnlflag: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToStringRange(
        sa: *mut SARRAY,
        first: l_int32,
        nstrings: l_int32,
        addnlflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayConcatUniformly(sa: *mut SARRAY, n: l_int32, addnlflag: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayJoin(sa1: *mut SARRAY, sa2: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppendRange(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        start: l_int32,
        end: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayPadToSameSize(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        padstring: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertWordsToLines(sa: *mut SARRAY, linesize: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySplitString(
        sa: *mut SARRAY,
        str_: *const ::std::os::raw::c_char,
        separators: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarraySelectBySubstring(
        sain: *mut SARRAY,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySelectRange(sain: *mut SARRAY, first: l_int32, last: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayParseRange(
        sa: *mut SARRAY,
        start: l_int32,
        pactualstart: *mut l_int32,
        pend: *mut l_int32,
        pnewstart: *mut l_int32,
        substr: *const ::std::os::raw::c_char,
        loc: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayRead(filename: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadStream(fp: *mut FILE) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadMem(data: *const l_uint8, size: size_t) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayWrite(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStream(fp: *mut FILE, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStderr(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppend(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn getNumberedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getSortedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn convertSortedToNumberedPathnames(
        sa: *mut SARRAY,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getFilenamesInDirectory(dirname: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySort(saout: *mut SARRAY, sain: *mut SARRAY, sortorder: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySortByIndex(sain: *mut SARRAY, naindex: *mut NUMA) -> *mut SARRAY;
}
extern "C" {
    pub fn stringCompareLexical(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_asetCreateFromSarray(sa: *mut SARRAY) -> *mut L_ASET;
}
extern "C" {
    pub fn sarrayRemoveDupsByAset(sas: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByAset(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByAset(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromSarray(sa: *mut SARRAY) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn sarrayRemoveDupsByHmap(
        sas: *mut SARRAY,
        psad: *mut *mut SARRAY,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByHmap(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByHmap(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayGenerateIntegers(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayLookupCSKV(
        sa: *mut SARRAY,
        keystring: *const ::std::os::raw::c_char,
        pvalstring: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScale(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSizeRel(pixs: *mut PIX, delw: l_int32, delh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToResolution(
        pixs: *mut PIX,
        target: l_float32,
        assumed: l_float32,
        pscalefact: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGeneral(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        sharpfract: l_float32,
        sharpwidth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColorLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySampling(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySamplingToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleByIntSampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGrayFast(pixs: *mut PIX, factor: l_int32, color: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmooth(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmoothToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGray2(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMapToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBinary(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayFast(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray3(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray6(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayMipmap(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleMipmap(pixs1: *mut PIX, pixs2: *mut PIX, scale: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandReplicate(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax(
        pixs: *mut PIX,
        xfact: l_int32,
        yfact: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax2(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRankCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRank2(pixs: *mut PIX, rank: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScaleWithAlpha(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinary(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinaryRestricted(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        xmax: l_int32,
        ymax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHolesByFilling(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillClosedBorders(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillBgFromBorder(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillHolesToBoundingRect(
        pixs: *mut PIX,
        minsize: l_int32,
        maxhfract: l_float32,
        minfgfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillGray(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInv(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGraySimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInvSimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayBasin(
        pixb: *mut PIX,
        pixm: *mut PIX,
        delta: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDistanceFunction(
        pixs: *mut PIX,
        connectivity: l_int32,
        outdepth: l_int32,
        boundcond: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedspread(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixLocalExtrema(
        pixs: *mut PIX,
        maxmin: l_int32,
        minmax: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectedLocalExtrema(
        pixs: *mut PIX,
        mindist: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindEqualValues(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectMinInConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        ppta: *mut *mut PTA,
        pnav: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRemoveSeededComponents(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        bordersize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaCreate(n: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn selaDestroy(psela: *mut *mut SELA);
}
extern "C" {
    pub fn selCreate(
        height: l_int32,
        width: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selDestroy(psel: *mut *mut SEL);
}
extern "C" {
    pub fn selCopy(sel: *mut SEL) -> *mut SEL;
}
extern "C" {
    pub fn selCreateBrick(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        type_: l_int32,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateComb(factor1: l_int32, factor2: l_int32, direction: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn create2dIntArray(sy: l_int32, sx: l_int32) -> *mut *mut l_int32;
}
extern "C" {
    pub fn selaAddSel(
        sela: *mut SELA,
        sel: *mut SEL,
        selname: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetCount(sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selaGetSel(sela: *mut SELA, i: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selGetName(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selSetName(sel: *mut SEL, name: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn selaFindSelByName(
        sela: *mut SELA,
        name: *const ::std::os::raw::c_char,
        pindex: *mut l_int32,
        psel: *mut *mut SEL,
    ) -> l_ok;
}
extern "C" {
    pub fn selGetElement(sel: *mut SEL, row: l_int32, col: l_int32, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selSetElement(sel: *mut SEL, row: l_int32, col: l_int32, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetParameters(
        sel: *mut SEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selSetOrigin(sel: *mut SEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetTypeAtOrigin(sel: *mut SEL, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selaGetBrickName(
        sela: *mut SELA,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaGetCombName(
        sela: *mut SELA,
        size: l_int32,
        direction: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getCompositeParameters(
        size: l_int32,
        psize1: *mut l_int32,
        psize2: *mut l_int32,
        pnameh1: *mut *mut ::std::os::raw::c_char,
        pnameh2: *mut *mut ::std::os::raw::c_char,
        pnamev1: *mut *mut ::std::os::raw::c_char,
        pnamev2: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetSelnames(sela: *mut SELA) -> *mut SARRAY;
}
extern "C" {
    pub fn selFindMaxTranslations(
        sel: *mut SEL,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
        pxn: *mut l_int32,
        pyn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selRotateOrth(sel: *mut SEL, quads: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selaRead(fname: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selaReadStream(fp: *mut FILE) -> *mut SELA;
}
extern "C" {
    pub fn selRead(fname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selReadStream(fp: *mut FILE) -> *mut SEL;
}
extern "C" {
    pub fn selaWrite(fname: *const ::std::os::raw::c_char, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selaWriteStream(fp: *mut FILE, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selWrite(fname: *const ::std::os::raw::c_char, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selWriteStream(fp: *mut FILE, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selCreateFromString(
        text: *const ::std::os::raw::c_char,
        h: l_int32,
        w: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selPrintToString(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selCreateFromPta(
        pta: *mut PTA,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromPix(
        pix: *mut PIX,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selReadFromColorImage(pathname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromColorPix(
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selaCreateFromColorPixa(pixa: *mut PIXA, sa: *mut SARRAY) -> *mut SELA;
}
extern "C" {
    pub fn selDisplayInPix(sel: *mut SEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn selaDisplayInPix(
        sela: *mut SELA,
        size: l_int32,
        gthick: l_int32,
        spacing: l_int32,
        ncols: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaAddBasic(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddHitMiss(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaLinear(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaCombs(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddCrossJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn selaAddTJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn sela4ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela4and8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selMakePlusSign(size: l_int32, linewidth: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelWithRuns(
        pixs: *mut PIX,
        nhlines: l_int32,
        nvlines: l_int32,
        distance: l_int32,
        minlength: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelRandom(
        pixs: *mut PIX,
        hitfract: l_float32,
        missfract: l_float32,
        distance: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelBoundary(
        pixs: *mut PIX,
        hitdist: l_int32,
        missdist: l_int32,
        hitskip: l_int32,
        missskip: l_int32,
        topflag: l_int32,
        botflag: l_int32,
        leftflag: l_int32,
        rightflag: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGetRunCentersOnLine(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        minlength: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRunsOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSubsampleBoundaryPixels(pixs: *mut PIX, skip: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn adjacentOnPixelInRaster(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        pxa: *mut l_int32,
        pya: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayHitMissSel(
        pixs: *mut PIX,
        sel: *mut SEL,
        scalefactor: l_int32,
        hitcolor: l_uint32,
        misscolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearIP(pixs: *mut PIX, yloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixVShearIP(pixs: *mut PIX, xloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixHShearLI(
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearLI(
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewBoth(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskew(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkewAndDeskew(
        pixs: *mut PIX,
        redsearch: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewGeneral(
        pixs: *mut PIX,
        redsweep: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        redsearch: l_int32,
        thresh: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkew(pixs: *mut PIX, pangle: *mut l_float32, pconf: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweep(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        reduction: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearch(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScore(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScorePivot(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pivot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewOrthogonalRange(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        confprior: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindDifferentialSquareSum(pixs: *mut PIX, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindNormalizedSquareSum(
        pixs: *mut PIX,
        phratio: *mut l_float32,
        pvratio: *mut l_float32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamSpix(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderSpix(
        filename: *const ::std::os::raw::c_char,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderSpix(
        fp: *mut FILE,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sreadHeaderSpix(
        data: *const l_uint32,
        size: size_t,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamSpix(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemSpix(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemSpix(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSerializeToMemory(
        pixs: *mut PIX,
        pdata: *mut *mut l_uint32,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDeserializeFromMemory(data: *const l_uint32, nbytes: size_t) -> *mut PIX;
}
extern "C" {
    pub fn lstackCreate(n: l_int32) -> *mut L_STACK;
}
extern "C" {
    pub fn lstackDestroy(plstack: *mut *mut L_STACK, freeflag: l_int32);
}
extern "C" {
    pub fn lstackAdd(lstack: *mut L_STACK, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lstackRemove(lstack: *mut L_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lstackGetCount(lstack: *mut L_STACK) -> l_int32;
}
extern "C" {
    pub fn lstackPrint(fp: *mut FILE, lstack: *mut L_STACK) -> l_ok;
}
extern "C" {
    pub fn strcodeCreate(fileno: l_int32) -> *mut L_STRCODE;
}
extern "C" {
    pub fn strcodeCreateFromFile(
        filein: *const ::std::os::raw::c_char,
        fileno: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeGenerate(
        strcode: *mut L_STRCODE,
        filein: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeFinalize(
        pstrcode: *mut *mut L_STRCODE,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_getStructStrFromFile(
        filename: *const ::std::os::raw::c_char,
        field: l_int32,
        pstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindStrokeLength(pixs: *mut PIX, tab8: *mut l_int32, plength: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFindStrokeWidth(
        pixs: *mut PIX,
        thresh: l_float32,
        tab8: *mut l_int32,
        pwidth: *mut l_float32,
        pnahisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindStrokeWidth(
        pixa: *mut PIXA,
        thresh: l_float32,
        tab8: *mut l_int32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaModifyStrokeWidth(pixas: *mut PIXA, targetw: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixModifyStrokeWidth(pixs: *mut PIX, width: l_float32, targetw: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSetStrokeWidth(
        pixas: *mut PIXA,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSetStrokeWidth(
        pixs: *mut PIX,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn sudokuReadFile(filename: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuReadString(str_: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuCreate(array: *mut l_int32) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuDestroy(psud: *mut *mut L_SUDOKU);
}
extern "C" {
    pub fn sudokuSolve(sud: *mut L_SUDOKU) -> l_int32;
}
extern "C" {
    pub fn sudokuTestUniqueness(array: *mut l_int32, punique: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn sudokuGenerate(
        array: *mut l_int32,
        seed: l_int32,
        minelems: l_int32,
        maxtries: l_int32,
    ) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuOutput(sud: *mut L_SUDOKU, arraytype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAddSingleTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
        poverflow: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddTextlines(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        wtext: l_int32,
        firstindent: l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetTextline(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        pwidth: *mut l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaAddTextNumber(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        na: *mut NUMA,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddTextlines(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        sa: *mut SARRAY,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPixWithText(
        pixa: *mut PIXA,
        pixs: *mut PIX,
        reduction: l_int32,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfGetLineStrings(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        maxw: l_int32,
        firstindent: l_int32,
        ph: *mut l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn bmfGetWordWidths(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bmfGetStringWidth(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn splitStringToParagraphs(
        textstr: *mut ::std::os::raw::c_char,
        splitflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadTiff(filename: *const ::std::os::raw::c_char, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamTiff(fp: *mut FILE, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteTiff(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteTiffCustom(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiff(fp: *mut FILE, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiffWA(
        fp: *mut FILE,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadFromMultipageTiff(
        fname: *const ::std::os::raw::c_char,
        poffset: *mut size_t,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMultipageTiff(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMultipageTiff(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiff(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiffSA(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn fprintTiffInfo(fpout: *mut FILE, tiffile: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn tiffGetCount(fp: *mut FILE, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getTiffResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn readHeaderTiff(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderTiff(
        fp: *mut FILE,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemTiff(
        cdata: *const l_uint8,
        size: size_t,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findTiffCompression(fp: *mut FILE, pcomptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn extractG4DataFromFile(
        filein: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pminisblack: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemTiff(cdata: *const l_uint8, size: size_t, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemFromMultipageTiff(
        cdata: *const l_uint8,
        size: size_t,
        poffset: *mut size_t,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMemMultipageTiff(data: *const l_uint8, size: size_t) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMemMultipageTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pixa: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiffCustom(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        comptype: l_int32,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn setMsgSeverity(newsev: l_int32) -> l_int32;
}
extern "C" {
    pub fn returnErrorInt(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        ival: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn returnErrorFloat(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        fval: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn returnErrorPtr(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        pval: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn leptSetStderrHandler(
        handler: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn lept_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn filesAreIdentical(
        fname1: *const ::std::os::raw::c_char,
        fname2: *const ::std::os::raw::c_char,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertOnLittleEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnBigEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnLittleEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertOnBigEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn fileCorruptByDeletion(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCorruptByMutation(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileReplaceBytes(
        filein: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
        newdata: *mut l_uint8,
        newsize: size_t,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn genRandomIntOnInterval(
        start: l_int32,
        end: l_int32,
        seed: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn lept_roundftoi(fval: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_hashStringToUint64(str_: *const ::std::os::raw::c_char, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashStringToUint64Fast(
        str_: *const ::std::os::raw::c_char,
        phash: *mut l_uint64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hashPtToUint64(x: l_int32, y: l_int32, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashFloat64ToUint64(val: l_float64, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn findNextLargerPrime(start: l_int32, pprime: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn lept_isPrime(n: l_uint64, pis_prime: *mut l_int32, pfactor: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn convertIntToGrayCode(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertGrayCodeToInt(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn getLeptonicaVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn startTimer();
}
extern "C" {
    pub fn stopTimer() -> l_float32;
}
extern "C" {
    pub fn startTimerNested() -> L_TIMER;
}
extern "C" {
    pub fn stopTimerNested(rusage_start: L_TIMER) -> l_float32;
}
extern "C" {
    pub fn l_getCurrentTime(sec: *mut l_int32, usec: *mut l_int32);
}
extern "C" {
    pub fn startWallTimer() -> *mut L_WALLTIMER;
}
extern "C" {
    pub fn stopWallTimer(ptimer: *mut *mut L_WALLTIMER) -> l_float32;
}
extern "C" {
    pub fn l_getFormattedDate() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringNew(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringCopy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCopySegment(
        src: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplace(
        pdest: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringLength(src: *const ::std::os::raw::c_char, size: size_t) -> l_int32;
}
extern "C" {
    pub fn stringCat(
        dest: *mut ::std::os::raw::c_char,
        size: size_t,
        src: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringConcatNew(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoin(
        src1: *const ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoinIP(
        psrc1: *mut *mut ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringReverse(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtokSafe(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        psaveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringSplitOnToken(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        phead: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCheckForChars(
        src: *const ::std::os::raw::c_char,
        chars: *const ::std::os::raw::c_char,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringRemoveChars(
        src: *const ::std::os::raw::c_char,
        remchars: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        pcount: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
        pfound: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringFindEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn stringFindSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn arrayReplaceEachSequence(
        datas: *const l_uint8,
        dataslen: size_t,
        seq: *const l_uint8,
        seqlen: size_t,
        newseq: *const l_uint8,
        newseqlen: size_t,
        pdatadlen: *mut size_t,
        pcount: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn arrayFindEachSequence(
        data: *const l_uint8,
        datalen: size_t,
        sequence: *const l_uint8,
        seqlen: size_t,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn arrayFindSequence(
        data: *const l_uint8,
        datalen: size_t,
        sequence: *const l_uint8,
        seqlen: size_t,
        poffset: *mut l_int32,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn reallocNew(
        pindata: *mut *mut ::std::os::raw::c_void,
        oldsize: size_t,
        newsize: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn l_binaryRead(
        filename: *const ::std::os::raw::c_char,
        pnbytes: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadStream(fp: *mut FILE, pnbytes: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelect(
        filename: *const ::std::os::raw::c_char,
        start: size_t,
        nbytes: size_t,
        pnread: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelectStream(
        fp: *mut FILE,
        start: size_t,
        nbytes: size_t,
        pnread: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryWrite(
        filename: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn nbytesInFile(filename: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn fnbytesInFile(fp: *mut FILE) -> size_t;
}
extern "C" {
    pub fn l_binaryCopy(datas: *const l_uint8, size: size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryCompare(
        data1: *const l_uint8,
        size1: size_t,
        data2: *const l_uint8,
        size2: size_t,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCopy(
        srcfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileConcatenate(
        srcfile: *const ::std::os::raw::c_char,
        destfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileAppendString(
        filename: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileSplitLinesUniform(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        save_empty: l_int32,
        rootpath: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fopenReadStream(filename: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteStream(
        filename: *const ::std::os::raw::c_char,
        modestring: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopenReadFromMemory(data: *const l_uint8, size: size_t) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteWinTempfile() -> *mut FILE;
}
extern "C" {
    pub fn lept_fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn lept_fclose(fp: *mut FILE) -> l_ok;
}
extern "C" {
    pub fn lept_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lept_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lept_mkdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_rmdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_direxists(dir: *const ::std::os::raw::c_char, pexists: *mut l_int32);
}
extern "C" {
    pub fn lept_rm_match(
        subdir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rm(
        subdir: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rmfile(filepath: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_mv(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_cp(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn callSystemDebug(cmd: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn splitPathAtDirectory(
        pathname: *const ::std::os::raw::c_char,
        pdir: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn splitPathAtExtension(
        pathname: *const ::std::os::raw::c_char,
        pbasename: *mut *mut ::std::os::raw::c_char,
        pextension: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pathJoin(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn appendSubdirs(
        basedir: *const ::std::os::raw::c_char,
        subdirs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertSepCharsInPath(path: *mut ::std::os::raw::c_char, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn genPathname(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn makeTempDirname(
        result: *mut ::std::os::raw::c_char,
        nbytes: size_t,
        subdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn modifyTrailingSlash(
        path: *mut ::std::os::raw::c_char,
        nbytes: size_t,
        flag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_makeTempFilename() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn extractNumberFromFilename(
        fname: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSimpleCaptcha(
        pixs: *mut PIX,
        border: l_int32,
        nterms: l_int32,
        seed: l_uint32,
        color: l_uint32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRandomHarmonicWarp(
        pixs: *mut PIX,
        xmag: l_float32,
        ymag: l_float32,
        xfreq: l_float32,
        yfreq: l_float32,
        nx: l_int32,
        ny: l_int32,
        seed: l_uint32,
        grayval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWarpStereoscopic(
        pixs: *mut PIX,
        zbend: l_int32,
        zshiftt: l_int32,
        zshiftb: l_int32,
        ybendt: l_int32,
        ybendb: l_int32,
        redleft: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontal(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalSampled(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalLI(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShear(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearSampled(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearLI(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStereoFromPair(
        pix1: *mut PIX,
        pix2: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn wshedCreate(
        pixs: *mut PIX,
        pixm: *mut PIX,
        mindepth: l_int32,
        debugflag: l_int32,
    ) -> *mut L_WSHED;
}
extern "C" {
    pub fn wshedDestroy(pwshed: *mut *mut L_WSHED);
}
extern "C" {
    pub fn wshedApply(wshed: *mut L_WSHED) -> l_ok;
}
extern "C" {
    pub fn wshedBasins(
        wshed: *mut L_WSHED,
        ppixa: *mut *mut PIXA,
        pnalevels: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn wshedRenderFill(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn wshedRenderColors(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn pixaWriteWebPAnim(
        filename: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStreamWebPAnim(
        fp: *mut FILE,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMemWebPAnim(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut size_t,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamWebP(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemWebP(filedata: *const l_uint8, filesize: size_t) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderWebP(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemWebP(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteWebP(
        filename: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamWebP(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemWebP(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut size_t,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_jpegSetQuality(new_quality: l_int32) -> l_int32;
}
extern "C" {
    pub fn setLeptDebugOK(allow: l_int32);
}
extern "C" {
    pub fn pixaWriteFiles(
        rootname: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteDebug(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWrite(fname: *const ::std::os::raw::c_char, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteAutoFormat(filename: *const ::std::os::raw::c_char, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStream(fp: *mut FILE, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteImpliedFormat(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixChooseOutputFormat(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn getImpliedFileFormat(filename: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixGetAutoFormat(pix: *mut PIX, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getFormatExtension(format: l_int32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_fileDisplay(
        fname: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplay(pixs: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayWithTitle(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        title: *const ::std::os::raw::c_char,
        dispflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeColorSquare(
        color: l_uint32,
        size: l_int32,
        addlabel: l_int32,
        location: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_chooseDisplayProg(selection: l_int32);
}
extern "C" {
    pub fn changeFormatForMissingLib(pformat: *mut l_int32);
}
extern "C" {
    pub fn pixDisplayWrite(pixs: *mut PIX, reduction: l_int32) -> l_ok;
}
extern "C" {
    pub fn zlibCompress(datain: *const l_uint8, nin: size_t, pnout: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn zlibUncompress(datain: *const l_uint8, nin: size_t, pnout: *mut size_t) -> *mut l_uint8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
